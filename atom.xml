<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思无邪</title>
  
  <subtitle>个人博客 | 学习，思考，分享</subtitle>
  <link href="https://lizhengsi.github.io/atom.xml" rel="self"/>
  
  <link href="https://lizhengsi.github.io/"/>
  <updated>2021-05-30T06:27:35.830Z</updated>
  <id>https://lizhengsi.github.io/</id>
  
  <author>
    <name>正思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Hexo搭建个人博客</title>
    <link href="https://lizhengsi.github.io/skill/Build_a_personal_blog_based_on_Hexo/"/>
    <id>https://lizhengsi.github.io/skill/Build_a_personal_blog_based_on_Hexo/</id>
    <published>2018-02-27T12:19:45.000Z</published>
    <updated>2021-05-30T06:27:35.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个基于 <a href="https://nodejs.org/">Node.js</a>的快速、简洁且高效的博客框架，通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html">标签插件</a> 来快速的插入特定形式的内容。</p><a id="more"></a><h1 id="准备工作">准备工作</h1><p>准备工作主要配置相关环境和基本要求，新手建议在安装或注册账号时先使用搜索引擎了解详细的安装配置方法，避免后续出错。</p><h2 id="github账号">GitHub账号</h2><p>如没有使用过GitHub，前往<a href="https://github.com/">GitHub</a>注册一个账号，并了解下GitHub基本信息 ，此处省略...</p><h2 id="安装git">安装git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a> 。</li><li>Mac：使用 Homebrew, MacPorts ：<code>brew install git</code>;或下载 安装程序 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li></ul><p>检验是否安装成功： <code>$ git version</code></p><h2 id="安装node.js">安装Node.js</h2><p>去 <a href="https://nodejs.org/en/download/">Node.js</a> 官网下载所需系统的安装包，并根据提示安装即可。Node.js版本及对应的hexo版本如下：</p><table><thead><tr class="header"><th style="text-align: left;">Hexo 版本</th><th style="text-align: left;">最低兼容 Node.js 版本</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">5.0+</td><td style="text-align: left;">10.13.0</td></tr><tr class="even"><td style="text-align: left;">4.1 - 4.2</td><td style="text-align: left;">8.10</td></tr><tr class="odd"><td style="text-align: left;">4.0</td><td style="text-align: left;">8.6</td></tr><tr class="even"><td style="text-align: left;">3.3 - 3.9</td><td style="text-align: left;">6.9</td></tr><tr class="odd"><td style="text-align: left;">3.2 - 3.3</td><td style="text-align: left;">0.12</td></tr><tr class="even"><td style="text-align: left;">3.0 - 3.1</td><td style="text-align: left;">0.10 or iojs</td></tr><tr class="odd"><td style="text-align: left;">0.0.1 - 2.8</td><td style="text-align: left;">0.10</td></tr></tbody></table><p>检验是否安装成功： <code>$ node -v</code></p><h2 id="安装hexo">安装hexo</h2><p>上述两个必备程序安装成功之后，只需要通过npm便可以完成Hexo的安装了。 <code>$ npm install -g hexo-cli</code> 至此，完成环境配置。</p><h1 id="本地部署">本地部署</h1><h2 id="本地初始化">本地初始化</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h2 id="本地目录结构">本地目录结构</h2><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds&#x2F;</span><br><span class="line">├── source&#x2F;</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes&#x2F;</span><br></pre></td></tr></table></figure><ul><li>_config.yml</li></ul><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><ul><li>package.json</li></ul><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package.json&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>scaffolds</li></ul><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><ul><li>source</li></ul><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><ul><li>themes</li></ul><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h2 id="启动本地服务">启动本地服务</h2><p>在指定文件夹下，执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   &#x2F;&#x2F;或者hexo generate </span><br><span class="line">hexo s   &#x2F;&#x2F;或者hexo server，可以在http:&#x2F;&#x2F;localhost:4000&#x2F; 查看</span><br></pre></td></tr></table></figure><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容。到这里，本地的一些基本部署就基本完成了，接下来将本地部署推送至github，并通过访问github静态页面显示。</p><h1 id="远程部署">远程部署</h1><h2 id="创建仓库">创建仓库</h2><p>新建一个名为<code>username.github.io</code>的仓库，创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里。</p><h2 id="绑定域名">绑定域名</h2><h2 id="配置ssh-key">配置SSH key</h2><p>首先在本地创建<code>ssh key</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure><p>后面的<code>your_email@youremail.com</code>改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在<code>~/</code>(windows路径：/c/Users/username/)下生成<code>.ssh</code>文件夹，进去，打开<code>id_rsa.pub</code>，复制里面的<code>key</code>。</p><p>回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。</p><p>为了验证是否成功，在git bash下输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果是第一次的会提示是否continue，输入yes就会看到：You've successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。</p><p>接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;your name&quot;</span><br><span class="line">$ git config --global user.email &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure><h2 id="远程推送">远程推送</h2><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改配置本地配置文件_config.yml。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>其中， <code>hexo clean</code>清除了你之前生成的东西，也可以不加。 <code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写。</p><p><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写。</p><p>现在，在浏览器中输入<code>username.github.io</code>，便可以打开网页了。接下来，需要对hexo进行基本配置和主题配置。</p><h1 id="基本配置">基本配置</h1><p>这部分网上有很多写的比较好的，详见附录参考。</p><h1 id="主题配置">主题配置</h1><p>Hexo提供多种主题配置，参见<a href="https://hexo.io/themes/">hexo官网</a>主题界面，这里配置的是<a href="http://theme-next.iissnan.com/">Next主题</a>，简洁才是最美的。在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><h3 id="下载主题">下载主题</h3><p>如果你熟悉 <a href="http://git-scm.com/">Git</a>， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 <code>git pull</code> 来快速更新， 而不用再次下载压缩包替换。</p><ul><li><a href="http://theme-next.iissnan.com/getting-started.html#clone">克隆最新版本</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html#stable">下载稳定版本</a></li></ul><p>在终端窗口下，定位到 Hexo 站点目录下。使用 <code>Git</code> checkout 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><h3 id="启用主题">启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 <strong>站点配置文件</strong>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><p>启用 NexT 主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题">验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p><p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p><img src="/skill/Build_a_personal_blog_based_on_Hexo/validation-default-scheme-mac.png" class="" title="img"><p>现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p><h3 id="文件组成">文件组成</h3><p>包含主题文件，整个hexo文件结构目录如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">├──</span> <span class="string">.deploy_git/</span><span class="comment">#远程部署</span></span><br><span class="line"><span class="string">├──</span> <span class="string">node_modules/</span><span class="comment">#第三方插件</span></span><br><span class="line"><span class="string">├──</span> <span class="string">public/</span><span class="comment">#html源码，hexo g生成</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scaffolds/</span><span class="comment">#模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">draft.md</span><span class="comment">#草稿</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">page.md</span><span class="comment">#页面</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">post.md</span><span class="comment">#文章</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source/</span><span class="comment">#个人资源</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_posts/</span><span class="comment">#存放个人文章</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">about/</span><span class="comment">#后面是一些自定义文件夹</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">categories/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">life/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">reading/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">skill/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">tags/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">Tao/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">themes/</span><span class="comment">#主题</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">landscape/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">next/</span><span class="comment">#next主题</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">languages/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">layout/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">scripts/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">source/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">test/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">|</span>       <span class="string">└──_config.yml</span><span class="comment">#主题配置文件</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">└──</span> <span class="string">_config.yml</span><span class="comment">#站点配置文件</span></span><br></pre></td></tr></table></figure><p>Next主题目录如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">├──</span> <span class="string">.github</span>                <span class="comment">#github信息</span></span><br><span class="line"><span class="string">├──</span> <span class="string">languages</span>              <span class="comment">#多语言</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_en.yml</span>            <span class="comment">#默认语言</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">zh-CN.yml</span>          <span class="comment">#简体中文</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">zh-TW.yml</span>          <span class="comment">#繁体中文</span></span><br><span class="line"><span class="string">├──</span> <span class="string">layout</span>                 <span class="comment">#布局，根目录下的*.swig文件是对主页，分页，存档等的控制</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_custom</span>            <span class="comment">#可以自定义的模板，覆盖原有模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">head.swig</span>      <span class="comment">#文首样式</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">header.swig</span>    <span class="comment">#头部样式</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">sidebar.swig</span>   <span class="comment">#侧边栏样式</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_macro</span>             <span class="comment">#可以自定义的模板，覆盖原有模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">post.swig</span>      <span class="comment">#文章模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">reward.swig</span>    <span class="comment">#打赏模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">sidebar.swig</span>   <span class="comment">#侧边栏模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_partial</span>           <span class="comment">#局部的布局</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">head</span>           <span class="comment">#头部模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">search</span>         <span class="comment">#搜索模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">share</span>          <span class="comment">#分享模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_script</span>            <span class="comment">#局部的布局</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_third-party</span>       <span class="comment">#第三方模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_layout.swig</span>       <span class="comment">#主页面模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">index.swig</span>         <span class="comment">#主页面模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">page</span>               <span class="comment">#页面模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">tag.swig</span>           <span class="comment">#tag模板</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scripts</span>                <span class="comment">#script源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">tags</span>               <span class="comment">#tags的script源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">marge.js</span>           <span class="comment">#页面模板</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source</span>                 <span class="comment">#源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">css</span>                <span class="comment">#css源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">_common</span>        <span class="comment">#*.styl基础css</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">_custom</span>        <span class="comment">#*.styl自定义局部css</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">└──</span> <span class="string">_mixins</span>        <span class="comment">#mixins的css</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">fonts</span>              <span class="comment">#字体</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">images</span>             <span class="comment">#图片</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">js</span>                 <span class="comment">#javascript源代码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">lib</span>                <span class="comment">#引用库</span></span><br><span class="line"><span class="string">├──</span> <span class="string">_config.yml</span>            <span class="comment">#主题配置文件</span></span><br><span class="line"><span class="string">└──</span> <span class="string">README.md</span>              <span class="comment">#说明文件</span></span><br></pre></td></tr></table></figure><p>可以根据自己的需要进行适当修改。</p><h3 id="选项配置">选项配置</h3><p>在配置Next主题时一些细节已经遗忘，主要是参照参考项中一些博客，可根据个人需求进行配置，以下简单列举在配置主题时的一些设置项：</p><ul><li><p>页面&amp;菜单布局</p><p>采用Next主题中的Gemini布局，菜单栏在侧栏，主题配置文件如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure><p>菜单中含几个类别，我想把不同的文章归类在不同类别下显示，总的目录是categories/，比如新建一个类别skill，则在主题配置文件中修改如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">skill:</span> <span class="string">/categories/skill/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-arrow-down</span></span><br></pre></td></tr></table></figure><p>在-CN.yml文件中修改中文映射，这样在主页时就会按映射的中文显示</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">skill:</span> <span class="string">问术</span></span><br></pre></td></tr></table></figure><p>然后在根目录，并在该目录生成文件index.md</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 问术</span><br><span class="line">layout: &quot;skill&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>这样，点击主页的“问术”按钮，则会显示skill分类页面</p><img src="/skill/Build_a_personal_blog_based_on_Hexo/image-20210530111244240.png" class="" title="image-20210530111244240"></li><li><p>网站映射</p><p>通过上述方式创建的skill页面的网址链接中会存在中文符，为了改成英文，在根目录下的站点配置文件中修改映射值，将链接中的中文映射为英语，这样就不会乱码了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">问术:</span> <span class="string">skill</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line">  <span class="comment">#算法</span></span><br><span class="line">  <span class="string">算法:</span> <span class="string">algorithm</span></span><br><span class="line">  <span class="string">滤波:</span> <span class="string">filter</span></span><br><span class="line">  <span class="string">点云:</span> <span class="string">point</span> <span class="string">cloud</span></span><br></pre></td></tr></table></figure></li><li><p>文章模板配置</p><p>以下是post模板，其中，公式采用mathjax渲染，增加<!-- more -->来显示摘要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">urltitle: </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">update: </span><br><span class="line"></span><br><span class="line">top: false</span><br><span class="line">toc: true</span><br><span class="line">comments: true</span><br><span class="line">mathjax: true</span><br><span class="line"></span><br><span class="line">keywords: </span><br><span class="line">description:</span><br><span class="line">tags: </span><br><span class="line">categories:</span><br><span class="line">- 111</span><br><span class="line">- 222</span><br><span class="line">- 333</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要显示....</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure></li><li><p>公式</p><p>首选，安装<a href="https://github.com/jgm/pandoc/releases/tag/2.6">pandoc</a>，然后，卸载hexo默认的markd，安装<code>hexo-renderer-pandoc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>安装hexo-math 插件以支持 latex 公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>在hexo 博客中的 _config.yml 中添加 hexo-math 插件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-emoji</span><br><span class="line">    - hexo-math</span><br></pre></td></tr></table></figure><p>打开 theme/next/_config.yml 文件，找到mathjax 位置, 设置为以下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure></li><li><p>markdown插入图片</p><p>首先，修改站点配置文件<code>_config.yml</code>中的<code>post_asset_folder: true</code></p><p>然后，使用typora编辑MarkDown文件，并在图片设置项选择“复制到指定路径”，./${filename}</p><p>最后，使用<code>hexo new “我的博客”</code>，在文章目录创建新文章，并且创建同名文件夹存放图片</p></li></ul><h1 id="日常写作">日常写作</h1><ul><li><p>新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p></li><li><p>生成静态文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></li><li><p>服务器查看更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li><p>远程部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考">参考</h1><ul><li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li><li><a href="http://theme-next.iissnan.com/">NexT 使用文档</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">使用hexo+github搭建免费个人博客详细教程</a></li><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></li><li><a href="https://www.cnblogs.com/guide2it/articles/11111457.html">Hexo+NexT（一）：在Windows下安装Hexo+NexT及搭建博客</a></li><li><a href="https://www.cnblogs.com/wsmrzx/p/9439470.html">Hexo系列(四) NexT主题配置</a></li><li><a href="https://blog.csdn.net/as480133937/article/details/100138838/?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-4&amp;spm=1001.2101.3001.4242">Hexo-Next 主题博客个性化配置超详细</a></li><li><a href="http://www.chenlianhan.com/2020/03/20/HEXO-NEXT界面美化（持续更新）/">HEXO+NEXT界面美化</a></li><li><a href="https://blog.csdn.net/u012294515/article/details/83094693">Hexo | NexT打造一个炫酷博客</a></li><li>[<a href="https://blog.csdn.net/u012294515/article/details/83094693">Hexo+Github+jsDelivr+Vercel建站备忘录</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;Hexo&lt;/a&gt; 是一个基于 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;的快速、简洁且高效的博客框架，通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 &lt;a href=&quot;https://hexo.io/zh-cn/docs/tag-plugins.html&quot;&gt;标签插件&lt;/a&gt; 来快速的插入特定形式的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="问术" scheme="https://lizhengsi.github.io/categories/skill/"/>
    
    
    <category term="hexo" scheme="https://lizhengsi.github.io/tags/hexo/"/>
    
    <category term="github" scheme="https://lizhengsi.github.io/tags/github/"/>
    
    <category term="blog" scheme="https://lizhengsi.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>关于Kalman滤波的理解</title>
    <link href="https://lizhengsi.github.io/skill/Understanding_of_Kalman_Filter/"/>
    <id>https://lizhengsi.github.io/skill/Understanding_of_Kalman_Filter/</id>
    <published>2016-08-30T07:58:52.000Z</published>
    <updated>2021-05-25T16:20:57.722Z</updated>
    
    <content type="html"><![CDATA[<p>卡尔曼滤波（Kalman filter）以它的发明者Rudolf. Emil. Kalman先生命名，是一种高效率的递归滤波器（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。在控制领域，Kalman滤波被称为<strong>线性二次型估计</strong>，其也可以认为是一个最优化自回归数据处理算法（optimal recursive data processing algorithm），广泛应用于飞机及太空船的导引、导航及控制。</p><a id="more"></a><hr /><h1 id="前言">前言</h1><p>写在本文之前，有两个重要的思想需贯穿脑海之中：  </p><blockquote><p>    1. 没有绝对准确，只有更为接近的准确<br />    2. 滤波即为加权  关于1，这个不做多说。</p></blockquote><p>关于2，对信号的滤波即是对离散序列的加权，传统的低通滤波器可以理解为高频权值为0（或接近0），而低频的权值为1，此时便可实现通低频阻高频的效果。同理，高通、带通滤波器可以理解为对不同频段的信号进行加权后获得想要的信号。 </p><h1 id="基本概念">基本概念</h1><h2 id="协方差矩阵"> 协方差矩阵</h2><p>设X、Y为随机变量，<span class="math inline">\(\mu\)</span>、<span class="math inline">\(\nu\)</span>分别为X、Y的期望。x、y分别为X、Y的真实值，<span class="math inline">\(\hat{x}\)</span>、<span class="math inline">\(\hat{y}\)</span>分别为x、y的估计值，则有：</p><ul><li><p><strong>误差</strong>：真实值与估计值的差，即<span class="math inline">\(e=x-\hat{x}\)</span></p></li><li><p><strong>方差</strong>：方差是描述随机变量与其期望值的离散程度，即<span class="math inline">\(\sigma_{X}^{2}=E(X-E(X))\)</span></p></li><li><p><strong>协方差</strong>：描述两个变量间的相关性，<span class="math inline">\(cov(X,Y)=E[(X-\mu)(Y-\nu)]\)</span> 。其中，X与Y的不相关是独立的必要不充分条件，但是对于X、Y正态分布时二者独立是不相关的充要条件。</p></li><li><p><strong>协方差矩阵</strong>：若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据；<span class="math inline">\(\mathrm{Y}\)</span>为n维向量<span class="math inline">\(\mathrm{Y}=(Y_{1},Y_{2},…,Y_{n})\)</span>，其中<span class="math inline">\(Y_{k}\)</span>中含一组数据,则<span class="math inline">\(\mathrm{X}\)</span>与<span class="math inline">\(\mathrm{Y}\)</span>的协方差应表示为mxn维协方差矩阵： <span class="math display">\[cov(\mathrm{X},\mathrm{Y})=E((\mathrm{X}-\mathrm{\mu})(\mathrm{Y}-\mathrm{\nu})^{T})=\begin{bmatrix}E[(X_{1}-\mu_{1})(Y_{1}-\nu_{1})] &amp; E[(X_{1}-\mu_{1})(Y_{2}-\nu_{2})] &amp;\cdots &amp;E[(X_{1}-\mu_{1})(Y_{n}-\nu_{n})] \\ E[(X_{2}-\mu_{2})(Y_{1}-\nu_{1})]&amp; E[(X_{2}-\mu_{2})(Y_{2}-\nu_{2})] &amp; \cdots  &amp;E[(X_{2}-\mu_{2})(Y_{n}-\nu_{n})] \\ \vdots                                         &amp; \vdots    &amp; \ddots    &amp; \vdots\\  E[(X_{m}-\mu_{m})(Y_{1}-\nu_{1})]&amp;  E[(X_{m}-\mu_{m})(Y_{2}-\nu_{2})]&amp; \cdots  &amp; E[(X_{m}-\mu_{m})(Y_{n}-\nu_{n})]\end{bmatrix}\]</span> 对于<span class="math inline">\(\mathrm{X}\)</span>自身而言，其协方差矩阵(或称为方差，详见<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%20%22wiki-协方差矩阵%22">协方差矩阵</a>)： <span class="math display">\[cov(\mathrm{X},\mathrm{X})=E((\mathrm{X}-\mathrm{\mu})(\mathrm{X}-\mathrm{\mu})^{T})=\begin{bmatrix}E[(X_{1}-\mu_{1})(X_{1}-\mu_{1})] &amp; E[(X_{1}-\mu_{1})(X_{2}-\mu_{2})] &amp;\cdots &amp;E[(X_{1}-\mu_{1})(X_{n}-\mu_{n})] \\ E[(X_{2}-\mu_{2})(X_{1}-\mu_{1})]&amp; E[(X_{2}-\mu_{2})(X_{2}-\mu_{2})] &amp; \cdots  &amp;E[(X_{2}-\mu_{2})(X_{n}-\mu_{n})] \\ \vdots                                         &amp; \vdots    &amp; \ddots    &amp; \vdots\\  E[(X_{m}-\mu_{m})(X_{1}-\mu_{1})]&amp;  E[(X_{m}-\mu_{m})(X_{2}-\mu_{2})]&amp; \cdots  &amp; E[(X_{m}-\mu_{m})(X_{n}-\mu_{n})]\end{bmatrix}\]</span> 可以从上式可以看出，矩阵对角为<span class="math inline">\(\mathrm{X}\)</span>列向量的方差。若<span class="math inline">\(\mathrm{X}\)</span>服从正态分布，其为对角矩阵。（后面可将<span class="math inline">\(\mathrm{X}\)</span>联想为状态向量，<span class="math inline">\(X_{1}\)</span>、<span class="math inline">\(X_{2}\)</span>联想为位移向量和速度向量）</p></li><li><p><strong>误差的协方差矩阵</strong>：若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据，误差为m维向量<span class="math inline">\(\mathrm{e}\)</span>，则其误差的协方差矩阵为： <span class="math display">\[P=cov(\mathrm{e},\mathrm{e})=E[\mathrm{e} \mathrm{e}^{T}]\]</span> 可知，其对角元素元素之和（或称迹）即为均方差。</p></li></ul><p> 注：此处十分重要，将状态变量的误差协方差矩阵与状态变量的最小均方差估计联系起来。</p><h2 id="最小均方误差估计">最小均方误差估计</h2><ul><li><strong>均方误差</strong>：它是"误差"的平方的，也就是多个样本的时候，均方差等于每个样本的误差平方再乘以该样本出现的概率的和，即 <span class="math display">\[MSE=E[(x-\hat{x})^{2}]=E[e^{2}]\]</span> 若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据，则<span class="math inline">\(\mathrm{X}\)</span>的均方误差：</li></ul><p><span class="math display">\[MSE=E[(\mathrm{x}-\mathrm{\hat{x}})^{T}(\mathrm{x}-\mathrm{\hat{x})}]=E[\mathrm{e}^{T}\mathrm{e}]=tr(E[\mathrm{e}\mathrm{e}^{T}])=\sum_{i=1}^{m}E[\mathrm{e}_{i}^{2}]\]</span></p><p>​ 注意，这里的<span class="math inline">\(\mathrm{e}\)</span>为m维向量，<span class="math inline">\(\mathrm{X}\)</span>的均方误差即为误差平方和的期望值，或误差平方的期望之和，这即是误差协方差矩阵的迹。</p><ul><li><strong>最小均方差（MMSE）</strong>：对于变量<span class="math inline">\(\mathrm{X}\)</span>，求其某一估计值，使均方误差最小，其最小均方误差即为：</li></ul><p><span class="math display">\[MMSE=MSE_{min}=E[(\mathrm{x}-\mathrm{\hat{x}})^{T}(\mathrm{x}-\mathrm{\hat{x})}]=E[\mathrm{e}^{T}\mathrm{e}]=tr(E[\mathrm{e}\mathrm{e}^{T}])=\sum_{i=1}^{m}E[\mathrm{e}_{i}^{2}]\]</span></p><ul><li><strong>最小均方误差估计</strong>：最小均方误差估计即最优估计，即寻找合适的估计函数<span class="math inline">\(\hat{x}=c(x)\)</span>来估计x，使上式最小。 （1）<span class="math inline">\(\mathrm{X}\)</span>为一维变量时，该估计函数为： <span class="math display">\[\hat{x}=E[X]\]</span> 其证明详见参考文献，大致过程是通过<span class="math inline">\(MSE_{min}\)</span>对<span class="math inline">\(\hat{x}\)</span>求导，令导函数为0，即可求得<span class="math inline">\(\hat{x}\)</span> 。  <br />（2）当<span class="math inline">\(\mathrm{X}\)</span>存在先验条件<span class="math inline">\(\mathrm{Y}\)</span>时，该估计函数为： <span class="math display">\[\hat{x}=E[X|Y=y]\]</span> 此时，该估计函数即为<span class="math inline">\(\mathrm{X}\)</span>在<span class="math inline">\(\mathrm{Y}\)</span>条件下的条件期望。其证明详见参考文献，证明过程同上。 （3） 当<span class="math inline">\(\mathrm{X}\)</span>存在先验条件<span class="math inline">\(\mathrm{Y}\)</span>，且<span class="math inline">\(\mathrm{X}\)</span>、<span class="math inline">\(\mathrm{Y}\)</span>为m维向量时，该估计函数为：</li></ul><p><span class="math display">\[\hat{x}(x_{1},x_{1},···,x_{m})=E[X|Y_{1}=y_{1},Y_{2}=y_{2},···,Y_{m}=y_{m}]\]</span></p><h2 id="状态描述">状态描述</h2><p>机器人的状态，是指一组完整描述它随时间运动的物理量，比如位置、角度和速度，状态估计即是在包含噪声的测量值中估计机器人的状态值，均方误差越小，估计值越接近真实值。</p><p>根据牛顿运动规律，物体的运动方程大体归结为化成如下形式： <span class="math display">\[m\frac{\mathrm{d}^{2} x}{\mathrm{d} t^{2}}+2\beta \frac{\mathrm{d} x}{\mathrm{d} t}+kx=u(t)\]</span> 化成以下形式：<br /><span class="math display">\[\ddot{x}-a_{1}\dot{x}-a_{0}x=u(t)\]</span> 再写成方程组形式：<br /><span class="math display">\[\left\{\begin{matrix}\dot{x}=0\cdot x+1\cdot\dot{x}+0\cdot u(t) &amp; &amp; \\ \ddot{x}=a_{0}x+a_{1}\dot{x}+1\cdot u(t)&amp; &amp; \end{matrix}\right.\]</span> 其矩阵形式： <span class="math display">\[\begin{pmatrix}\dot{x}\\ \ddot{x}\end{pmatrix}=  \begin{pmatrix}0 &amp; 1\\ a_{0}&amp; a_{1}\end{pmatrix}\begin{pmatrix}\ x\\ \dot{x}\end{pmatrix}  +  \begin{pmatrix}\ 0\\ \ 1\end{pmatrix}u(t)\]</span> 化简为： <span class="math display">\[\mathbf{\dot{x}}=\mathbf{Ax}+\mathbf{Bu}\]</span> 如果在方程中加入过程噪声，则有： <span class="math display">\[\ddot{x}=a_{1}\dot{x}+a_{0}x+u(t)+w(t)\]</span> 得到类似矩阵：<br /><span class="math display">\[\begin{pmatrix}\dot{x}\\ \ddot{x}\end{pmatrix}=  \begin{pmatrix}0 &amp; 1\\ a_{0}&amp; a_{1}\end{pmatrix}\begin{pmatrix}\ x\\ \dot{x}\end{pmatrix}  +\begin{pmatrix}\ 0\\ \ 1\end{pmatrix}u(t)  +\begin{pmatrix}\ 0\\ \ 1\end{pmatrix}w(t)\]</span> <strong>运动方程</strong>简化为：<br /><span class="math display">\[\mathbf{\dot{x}}=\mathbf{Ax}+\mathbf{Bu}+\mathbf{w}\]</span> <em>其中，<strong>A</strong>：传输矩阵； <strong>x</strong>：状态矢量； <strong>B</strong>：控制矩阵； <strong>u</strong>：控制矢量； <strong>w</strong>：过程噪声</em>  </p><p><strong>在这里，状态向量<span class="math inline">\(\mathbf=（x,\dot{x}）\)</span>包含位移和速度的信息。推广到多维空间，状态向量为<span class="math inline">\(\mathbf=（x_{1},x_{2},...,x_{n};\dot{x_{1}},\dot{x_{2}},...,\dot{x_{n}}）\)</span>，这种方法称为状态空间描述法。</strong></p><p>由此得到系统模型框图：</p><img src="/skill/Understanding_of_Kalman_Filter/%E8%BF%90%E5%8A%A8%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220600134"><p>除了物体运动方程，当在x状态处观测，可以得到一个观测方程： <span class="math display">\[\mathbf{z}=\mathbf{Hx}+\mathbf{v}\]</span> <em>其中，<strong>z</strong>：观测矢量； <strong>H</strong>：观测矩阵；<strong>v</strong>：观测噪声</em> 。</p><p>更新以上系统框图，则有：</p><img src="/skill/Understanding_of_Kalman_Filter/%E8%A7%82%E6%B5%8B%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220741655"><h1 id="kalman滤波器">Kalman滤波器</h1><h2 id="前提条件"> 前提条件</h2><ul><li>线性系统  </li><li>系统噪声和测量噪声服从高斯分布  </li></ul><h2 id="系统模型"> 系统模型</h2><p>卡尔曼滤波建立在线性代数和隐马尔可夫模型上，k时刻的状态在(k-1)时刻的基础上递推过来，系统模型由预测空间模型和观测空间模型组成。在上述运动方程和观测方程基础上，进行离散化并得到状态方程的形式，如下预测空间模型和观测空间模型。</p><p><strong>预测空间模型：</strong> <span class="math display">\[\mathbf{x_{k}}=\mathbf{Ax_{k-1}}+\mathbf{Bu_{k-1}}+\mathbf{w_{k-1}}\]</span> 其中：</p><ul><li><span class="math inline">\(\mathbf{x_{k}}\)</span>是k时刻的预测状态向量，<span class="math inline">\(\mathbf{x_{k-1}}\)</span>是(k-1)时刻的状态向量  </li><li><span class="math inline">\(\mathbf{u_{k-1}}\)</span>是(k-1)时刻的控制输入向量</li><li><span class="math inline">\(\mathbf{A}\)</span>是k时刻状态传输矩阵，与系统本身特性相关，其隐含指示(k-1)时刻的状态会影响到k时刻的状态  </li><li><span class="math inline">\(\mathbf{B}\)</span>是k时刻控制输入矩阵，其隐含指示(k-1)时刻的驱动输入会影响到k时刻的状态  </li><li><span class="math inline">\(\mathbf{w_{k}}\)</span>是过程噪声，服从正态分布，<span class="math inline">\(\mathbf{w_{k}}\sim N(0,Q_{k})\)</span>，<span class="math inline">\(\mathbf{Q_{k}}\)</span>为其协方差矩阵  </li></ul><p><strong>观测空间模型：</strong><br /><span class="math display">\[ \mathbf{z_{k}}=\mathbf{Hx_{k}}+\mathbf{v_{k}} \]</span> 其中：</p><ul><li><span class="math inline">\(\mathbf{z_{k}}\)</span>是k时刻的观测状态向量  </li><li><span class="math inline">\(\mathbf{H}\)</span>是k时刻的观测矩阵，把真实状态空间映射成观测空间  </li><li><span class="math inline">\(\mathbf{v_{k}}\)</span>是观测噪声，服从正态分布，<span class="math inline">\(\mathbf{v_{k}}\sim N(0,R_{k})\)</span>，<span class="math inline">\(\mathbf{R_{k}}\)</span>为其协方差矩阵  </li></ul><p>分析上述两个状态方程，不拿看出，在k时刻的预测状态向量<span class="math inline">\(\mathbf{x_{k}}\)</span>（或观测状态向量<span class="math inline">\(\mathbf{z_{k}}\)</span>）是在第(k-1)时刻的状态上推导而来（马尔科夫模型），并且都在状态更新的过程中带入新的高斯噪声。离散框图如下：</p><img src="/skill/Understanding_of_Kalman_Filter/%E7%A6%BB%E6%95%A3%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220852476"><p>那么问题来了，既然既可以通过预测，亦可以通过观测，来获知系统在k时刻的状态，但是二者都存在误差（噪声），那么二者哪个更可靠呢？这时，我们自然而然的想到了的加权的思想，通过对二者的加权获得k时刻的准确的状态。  通过以下图片可以帮我们更好地理解，小车距出发地的距离可以通过预测模型和测量模型获得，且二者都服从正态分布，都存在误差。通过对二者加权，得到我们想要的较为准确的状态模型（图中绿色表示），但是，这个模型也存在误差，服从正态分布。</p><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A601.jpg" class="" title="示例小车01"><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A602.jpg" class="" title="示例小车02"><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A603.jpg" class="" title="示例小车03"><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A604.jpg" class="" title="示例小车04"><p><strong>综上，kalman滤波可以看做是对预测模型和观测模型进行加权处理，获取更加接近实际值新的状态估计值。实际上，kalman滤波即是利用观测模型的残差来修正预测模型（最优估计），同时计算残差的权值。</strong>  </p><h2 id="递推方程"> 递推方程</h2><p>kalman滤波器用于估计离散时间过程的状态变量<span class="math inline">\(x\in\Re^{n}\)</span>，这个离散时间过程由以下离散随机差分方程描述：</p><p>设<span class="math inline">\(\mathbf{x}_{k}^{-}\in\Re^{n}\)</span>(-代表先验，^代表估计)为在已知第 k步以前状态情况下第 k 步的先验状态估计。<span class="math inline">\(\mathbf{\hat{x}}_{k}\in\Re^{n}\)</span>为已知测量变量<span class="math inline">\(\mathbf{z}_{k}\)</span>时第k步的后验状态估计。由此定义先验估计误差和后验估计误差： <span class="math display">\[\mathbf{e_{k}^{-}}=\mathbf{x_{k}} - \mathbf{\hat{x}_{k}^{-}}  ,  \mathbf{e_{k}}=\mathbf{x_{k}}  -  \mathbf{\hat{x}_{k}}\]</span> 先验估计误差的协方差为： <span class="math display">\[\mathbf{P_{k}^{-}} = E[\mathbf{e_{k}^{-}}  \mathbf{(e_{k}^{-})^{T}}]\]</span> 后验估计误差的协方差为： <span class="math display">\[\mathbf{P_{k}} = E[\mathbf{e_{k}}  \mathbf{(e_{k})^{T}}]\]</span> 那么，对于预测和测量状态空间方程，即为：</p><p><strong>预测空间模型-预测值（先验估计）：</strong> <span class="math display">\[\mathbf{\hat{x}_{k}^{-}}=\mathbf{A\hat{x}_{k-1}}+\mathbf{B{u}_{k-1}}\]</span> <strong>观测空间模型-测量值（测量值的预测）：</strong><br /><span class="math display">\[\mathbf{\hat{z}_{k}}=\mathbf{H\hat{x}_{k}^{-}}\]</span></p><blockquote><p>  实际测量值：$ = +  =  + $</p></blockquote><p>这时，要在测量值的基础上再次更新状态变量<span class="math inline">\(x\)</span>的先验估计，可得到后验估计，得到最优估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>： <span class="math display">\[\mathbf{\hat{x}_{k}} = \mathbf{\hat{x}_{k}^{-}} + \mathbf{K_{k}} (\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})\]</span> 上式构造了kalman滤波器的表达式，先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>和加权的预测残差<span class="math inline">\((\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})\)</span>线性的构成了后验状态估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>。</p><h2 id="递推方程的解释">递推方程的解释</h2><p>（1） <span class="math inline">\(\mathbf{x_{k}}\)</span> 的概率原型。这个可以见参考文献，来源于贝叶斯规则：<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的更新取决于在已知先前的测量变量<span class="math inline">\(\mathbf{z_{k}}\)</span>的情况下<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>的概率分布。在已知 <span class="math inline">\(\mathbf{z_{k}}\)</span>的情况下，<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的分布可写为： <span class="math display">\[p(\mathbf{x_{k}} | \mathbf{z_{k}}) - N(\mathbf{\hat{x}_{k}},\mathbf{P_{k}})\]</span> 即为正态分布。</p><p>（2） <span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的推导。关于<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的形式，利用最优估计的原理，可以用极大似然估计可以推导，在论文中还看到过一种是将预测和测量的正态分布相乘求联合正态分布，联合正态分布即为后验状态估计。这里应该可以用反馈的原理来解释（如下面这张图），以测量值作为反馈，来进一步修正状态变量<span class="math inline">\(x\)</span>的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>，得到后验估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>。</p><img src="/skill/Understanding_of_Kalman_Filter/%E5%8F%8D%E9%A6%88%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525222308034"><p>（3） <span class="math inline">\(\mathbf{K_{k}}\)</span>的推导。既然<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>是<span class="math inline">\(\mathbf{x_{k}}\)</span>的最优估计，那么<span class="math inline">\(\mathbf{x_{k}}\)</span>的误差协方差矩阵的迹<span class="math inline">\(tr[\mathbf{P_{k}}]\)</span>(<span class="math inline">\(\mathbf{P_{k}}\)</span>的计算见下面)最小，即<span class="math inline">\(\mathbf{x_{k}}\)</span>的均方误差最小。此时，将后验估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的表达式和误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>的表达式联立，即可求得<span class="math inline">\(tr[\mathbf{P_{k}}]\)</span>，对其求导，导函数为零时求得<span class="math inline">\(\mathbf{K_{k}}\)</span>： <span class="math display">\[\mathbf{K_{k}} = \mathbf{P_{k}^{-}}\mathbf{H^{T}}(\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R})^{-1}= \frac{\mathbf{P_{k}^{-}}\mathbf{H^{T}}}{\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R}}\]</span></p><h2 id="离散kalman滤波算法"> 离散Kalman滤波算法</h2><p>卡尔曼滤波器用反馈控制的方法估计过程状态：滤波器估计某一时刻的过程状态，然后以测量变量（含噪声）的方式获得反馈。</p><p>因此卡尔曼滤波器可分为两个部分：时间更新方程和测量更新方程。时间更新方程负责及时向前推算当前状态变量和误差协方差估计的值，以便为下一个时间状态构造先验估计。测量更新方程负责反馈，它将先验估计和新的测量变量结合以构造改进的后验估计。时间更新方程也可视为预估方程，测量更新方程可视为校正方程。最后的估计算法成为一种具有数值解的预估－校正算法。</p><img src="/skill/Understanding_of_Kalman_Filter/%E9%A2%84%E6%B5%8B%E6%A0%A1%E6%AD%A3.png" class="" title="image-20210525224607696"><p><strong>离散卡尔曼滤波时间更新方程</strong> <span class="math display">\[\left\{\begin{matrix}\mathbf{\hat{x}_{k}^{-}}=\mathbf{A\hat{x}_{k-1}}+\mathbf{Bu_{k-1}}\\ \mathbf{P_{k}^{-}}=\mathbf{A} \boldsymbol{P_{k-1}} \mathbf{A^{T}} + \mathbf{Q}\end{matrix}\right.\]</span> 时间更新方程主要获取由预测方程预测的k时刻的状态<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>，为<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的先验状态估计；此时，其误差的协方差矩阵为<span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>。</p><blockquote><p>  上式中，存在未知参数<span class="math inline">\(\mathbf{A}\)</span>, <span class="math inline">\(\mathbf{B}\)</span>, <span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>, <span class="math inline">\(\mathbf{P_{k-1}}\)</span>, <span class="math inline">\(\mathbf{Q}\)</span>  (1) 关于<span class="math inline">\(\mathbf{A}\)</span>。这是和状态向量相关的矩阵，具体见举例  (2) 关于<span class="math inline">\(\mathbf{B}\)</span>。这是驱动矩阵，和外部输入驱动有关，具体见举例  (3) 关于 <span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>。这是k时刻的先验状态估计的误差协方差矩阵，与预测方程的噪声有关，是根据（k-1）时刻的误差协方差矩阵<span class="math inline">\(\mathbf{P_{k-1}}\)</span>递推而来（<span class="math inline">\(\mathbf{P_{k-1}}\)</span>一般是给定的初值），利用<span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>的表达式 <span class="math inline">\(\mathbf{P_{k}^{-}} = E[\mathbf{e_{k}^{-}}  \mathbf{(e_{k}^{-})^{T}}]\)</span>即可求得。  (4) 关于<span class="math inline">\(\mathbf{P_{k-1}}\)</span>。（k-1）时刻的误差协方差矩阵（<span class="math inline">\(\mathbf{P_{k-1}}\)</span>一般是给定的初值）  (5) 关于<span class="math inline">\(\mathbf{Q}\)</span>。过程噪声（预测误差）<span class="math inline">\(\mathbf{w_{k-1}}\)</span>的协方差矩阵，在预测的过程中产生。</p></blockquote><p><strong>离散卡尔曼滤波状态更新方程</strong> <span class="math display">\[\left\{\begin{matrix}\mathbf{K_{k}} = \mathbf{P_{k}^{-}}\mathbf{H^{T}}(\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R})^{-1}\\\mathbf{\hat{x}_{k}} = \mathbf{\hat{x}_{k}^{-}} + \mathbf{K_{k}} (\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})\\ \mathbf{P_{k}}=(\mathbf{I} - \mathbf{K_{k}}\mathbf{H} )\mathbf{P_{k}^{-}}\end{matrix}\right.\]</span> 状态更新方程在预测的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>上，同测量值<span class="math inline">\(\mathbf{z_{k}}\)</span>进行融合，更新校正先验状态估计，得到k时刻的后验状态估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>；此时，递推出后验状态估计的误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>，由此可以得到MMSE的条件，求得<span class="math inline">\(\mathbf{K_{k}}\)</span></p><blockquote><p>  上式中，存在未知参数<span class="math inline">\(\mathbf{K_{k}}\)</span>, <span class="math inline">\(\mathbf{H}\)</span>, <span class="math inline">\(\mathbf{R}\)</span>, <span class="math inline">\(\mathbf{z_{k}}\)</span>, <span class="math inline">\(\mathbf{P_{k}}\)</span>  (1) 关于<span class="math inline">\(\mathbf{K_{k}}\)</span>。残差（真实测量值与基于先验状态估计的测量值（估计量））的增益，可以看做测量反馈的增益  (2) 关于<span class="math inline">\(\mathbf{H}\)</span>。这是观测矩阵，和状态向量有关，具体见举例  (3) 关于<span class="math inline">\(\mathbf{R}\)</span>。测量噪声（测量误差）<span class="math inline">\(\mathbf{v_{k-1}}\)</span>的协方差矩阵，在测量的过程中产生。   (4) 关于<span class="math inline">\(\mathbf{z_{k}}\)</span>。k时刻的真是测量值。  (5) 关于<span class="math inline">\(\mathbf{P_{k}}\)</span>。k时刻的后验估计的误差协方差矩阵。</p></blockquote><p>因此，通过时间更新和测量更新的不断递推，便可得到比较准确的状态向量估计值。其中，若初始过程噪声<span class="math inline">\(w_{k}\)</span>和测量噪声<span class="math inline">\(v_{k}\)</span>为一确定值，不断递推后状态向量误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>和卡尔曼增益<span class="math inline">\(\mathbf{K_{k}}\)</span>会收敛并保持常量。下图显示了滤波器整个操作流程。</p><img src="/skill/Understanding_of_Kalman_Filter/%E6%BB%A4%E6%B3%A2%E5%99%A8%E6%B5%81%E7%A8%8B.png" class="" title="image-20210525224729900"><hr /><h1 id="程序">程序</h1><h2 id="matlab程序"> Matlab程序</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% kalman filter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% x(k+1) = Fk * x(k) + Wk; 预测模型</span></span><br><span class="line"><span class="comment">% y(k)   = Hk * x(k) + Vk; 观测模型</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">365</span>;</span><br><span class="line"></span><br><span class="line">Fk = [<span class="number">1</span>];               <span class="comment">% 状态转移矩阵               </span></span><br><span class="line">X  = <span class="built_in">zeros</span>(N,<span class="number">1</span>);        <span class="comment">% 初始化状态变量</span></span><br><span class="line">W  = <span class="number">12</span>*<span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 构造过程噪声</span></span><br><span class="line">X(<span class="number">1</span>) = <span class="number">100</span>;             <span class="comment">% 初始状态</span></span><br><span class="line">                    </span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 状态方程</span></span><br><span class="line">    X(k) = Fk * X(k<span class="number">-1</span>) + W(k<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Hk = [<span class="number">2</span>];               <span class="comment">% 观测矩阵                </span></span><br><span class="line">Y  = <span class="built_in">zeros</span>(N,<span class="number">1</span>);        <span class="comment">% 初始化观测变量</span></span><br><span class="line">V  = <span class="number">20</span>*<span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 构造观测噪声</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:N</span><br><span class="line">    <span class="comment">% 观测方程</span></span><br><span class="line">    Y(k) = Hk * X(k) + V(k);   </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Q  = cov(W);            <span class="comment">% 过程噪声协方差；    </span></span><br><span class="line">R  = cov(V);            <span class="comment">% 观测噪声协方差；          </span></span><br><span class="line"></span><br><span class="line">Xupdate = <span class="built_in">zeros</span>(N,<span class="number">1</span>);   </span><br><span class="line">Xupdate(<span class="number">1</span>) = Y(<span class="number">1</span>);      <span class="comment">% 初始化第一个，也就是观测到的第一个 </span></span><br><span class="line">Pupdate(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 五大核心方程</span></span><br><span class="line">    Xpredict(k) = Fk * Xupdate(k<span class="number">-1</span>);</span><br><span class="line">    Ppredict(k) = Fk * Pupdate(k<span class="number">-1</span>) * Fk&#x27; + Q;</span><br><span class="line">    K = Ppredict(k) * Hk * (Hk * Ppredict(k) * Hk&#x27; + R).^<span class="number">-1</span>;</span><br><span class="line">    Xupdate(k) = (<span class="number">1</span> - K * Hk) * Xpredict(k) + K * Y(k);</span><br><span class="line">    Pupdate(k) = (<span class="number">1</span> - K * Hk) * Ppredict(k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,X,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,Y,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,Xupdate,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,<span class="built_in">abs</span>(Xupdate-X),<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;真值&#x27;</span>,<span class="string">&#x27;观测值&#x27;</span>,<span class="string">&#x27;滤波值&#x27;</span>,<span class="string">&#x27;误差&#x27;</span>)</span><br></pre></td></tr></table></figure><hr /><h1 id="参考">参考</h1><ul><li>https://www.zhihu.com/question/23971601  </li><li>http://blog.csdn.net/xiahouzuoxin/article/details/39582483  </li><li>https://zhuanlan.zhihu.com/p/21889676  </li><li>https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2  </li><li>https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95</li><li>http://www.jianshu.com/p/2768642e3abf</li><li>http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/</li><li>Ramsey Faragher. Understanding the Basis of the Kalman Filter. 2012</li><li>Greg Welch, Gary Bishop. An Introduction to the Kalman Filter. 2001</li><li>Don Johnson. Minimum Mean Squared Error Estimators. 2004</li><li>R.E.Kalman. A new approach to linear filtering and prediction problems. 1960</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;卡尔曼滤波（Kalman filter）以它的发明者Rudolf. Emil. Kalman先生命名，是一种高效率的递归滤波器（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。在控制领域，Kalman滤波被称为&lt;strong&gt;线性二次型估计&lt;/strong&gt;，其也可以认为是一个最优化自回归数据处理算法（optimal recursive data processing algorithm），广泛应用于飞机及太空船的导引、导航及控制。&lt;/p&gt;</summary>
    
    
    
    <category term="问术" scheme="https://lizhengsi.github.io/categories/skill/"/>
    
    
    <category term="Kalman filter" scheme="https://lizhengsi.github.io/tags/Kalman-filter/"/>
    
  </entry>
  
</feed>
