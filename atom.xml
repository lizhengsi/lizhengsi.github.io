<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思无邪</title>
  
  <subtitle>个人博客 | 学习，思考，分享</subtitle>
  <link href="https://lizhengsi.github.io/atom.xml" rel="self"/>
  
  <link href="https://lizhengsi.github.io/"/>
  <updated>2021-05-30T11:32:16.786Z</updated>
  <id>https://lizhengsi.github.io/</id>
  
  <author>
    <name>正思</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>相机模型与标定</title>
    <link href="https://lizhengsi.github.io/skill/model_of_camera_imaging_and_camera_Calibration/"/>
    <id>https://lizhengsi.github.io/skill/model_of_camera_imaging_and_camera_Calibration/</id>
    <published>2021-05-30T09:39:26.000Z</published>
    <updated>2021-05-30T11:32:16.786Z</updated>
    
    <content type="html"><![CDATA[<p>张正友标定法是基于单平面棋盘格的相机标定方法，由张正友博士在1998年的论文："A Flexible New Technique for Camera Calibration"中提出，该方法介于传统的标定方法和自标定方法之间，使用简单实用性强，克服了传统标定法需要的高精度标定物的缺点，而仅需使用一个打印出来的棋盘格即可，便于操作，因此，广泛用于计算机视觉领域。</p><a id="more"></a><h1 id="概述">概述</h1><p>相机的基本成像模型和标定是计算机视觉的基础，本文主要阐述单目相机成像的基本数学模型，并在此基础上对张正友标定法进行了讲解，最后通过C++代码实现。</p><h1 id="相机模型">相机模型</h1><h2 id="针孔相机模型">针孔相机模型</h2><p>相机的成像过程基本是：现实世界-透镜中心-传感器成像-像素图像，应用小孔成像原理，可以建立现实世界的三维点和图片像素点之间的对应关系，即世界坐标系中的点和像素坐标系中的像素之间的几何关系。</p><img src="/skill/model_of_camera_imaging_and_camera_Calibration/image-20210407114045834.png" class="" title="image-20210407114045834"><p>假定世界坐标系中一点<span class="math inline">\(P_{w}(x_{w},y_{w},z_{w})\)</span>，通过相机光心<span class="math inline">\(O_{c}\)</span>投射到相机传感器上，即相机的物理成像平面，该投射点在相机坐标系中的坐标为<span class="math inline">\(P_{c}(x_{c},y_{c},z_{c})\)</span>，在像素坐标系下的坐标为<span class="math inline">\(P&#39;_{p}(u,v)\)</span>，这里，就是要建立<span class="math inline">\(P_{w}(x_{w},y_{w},z_{w})\)</span>和<span class="math inline">\(P&#39;_{p}(u,v)\)</span>之间的变换关系。</p><h2 id="坐标系">坐标系</h2><p>相机成像系统中，共包含四个坐标系：</p><ul><li><p>世界坐标系<span class="math inline">\(O(x_{w},y_{w},z_{w})\)</span>。世界坐标系固定不变，可作为绝对参考，一般主要关注相机坐标系和世界坐标系之间的旋转变换关系。单位是米。</p></li><li><p>相机坐标系<span class="math inline">\(O(x_{c},y_{c},z_{c})\)</span>。在相机镜片上，以相机光心为原点，是相机成像模型中最重要的计算坐标系，相机在世界坐标系中的位姿通过相机坐标系相对世界坐标系的变换矩阵来表示。单位是米。</p></li><li><p><strong>归一化相机坐标系<span class="math inline">\(O(x,y,1)\)</span></strong>。针对世界坐标系中任一点，在相机坐标系下归一化后得到与相机平面平行的面，它位于相机前方z=1处的平面上，称为归一化平面，此时，该坐标系上的点退化成二维点，通过某种映射关系（内参矩阵）可得到像素坐标。</p></li><li><p>图像坐标系<span class="math inline">\(O(x_{i},y_{i})\)</span>。在相机传感器上，以物理成像平面和相机坐标系z轴延长线相交点为原点，将成像平面对称到相机前方，可得到图像是正着的对称成像平面，便于实际计算。x、y方向上和相机坐标系是相等的，单位是毫米。</p></li><li><p>像素坐标系<span class="math inline">\(O(u,v)\)</span>。像素坐标系的原点在图像的左上角，即矩阵表示形式的起点。单位是像素。</p></li></ul><p>在单目相机的成像模型中，坐标系间的变换关系如下：</p><img src="/skill/model_of_camera_imaging_and_camera_Calibration/v2-665648ff84735e54ea26e34ed9096ba8_r.jpg" class="" title="img"><h2 id="基本投影几何">基本投影几何</h2><h3 id="像素坐标-图像坐标">像素坐标-图像坐标</h3><p>像素坐标和图像坐标之间相差了一个缩放和原点的平移，假设在<span class="math inline">\(u\)</span>轴上倍数为<span class="math inline">\(1/dx\)</span>，在<span class="math inline">\(v\)</span>轴上倍数为<span class="math inline">\(1/dy\)</span>，同时，原点平移了[<span class="math inline">\(c_{x}\)</span>,<span class="math inline">\(c_{y}\)</span>]。假设传感器的横边和纵边之间的角度为90°(表示无误差），点<span class="math inline">\(P&#39;\)</span>像素坐标系下<span class="math inline">\(P&#39;_{p}(u,v)\)</span>和图像坐标系下<span class="math inline">\(P&#39;_{i}(x&#39;_{i},y&#39;_{i})\)</span>之间的关系为： <span class="math display">\[\begin{bmatrix}u\\ v\\ 1\end{bmatrix}=\begin{bmatrix}\frac{1}{\mathrm{d}x} x&#39;_{i} + c_{x}\\ \frac{1}{\mathrm{d}y} y&#39;_{i} + c_{y}\\ 1\end{bmatrix}=\begin{bmatrix}\frac{1}{\mathrm{d}x} &amp; 0 &amp; c_{x}\\ 0 &amp; \frac{1}{\mathrm{d}y} &amp; c_{y}\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix}x&#39;_{i}\\ y&#39;_{i} \\ 1\end{bmatrix}\]</span> 其中，<span class="math inline">\(1/dx\)</span>、<span class="math inline">\(1/dx\)</span>单位为像素/毫米，表示一个像素在相机感光板上的物理长度；<span class="math inline">\(c_{x}\)</span>、<span class="math inline">\(c_{y}\)</span>单位为像素，表示相机感光板中心在像素坐标系下的坐标。</p><h3 id="像素坐标-相机坐标">像素坐标-相机坐标</h3><p>通过透视变换，相似三角形几何关系，在相机坐标系下，从点<span class="math inline">\(P_{c}(x_{c},y_{c},z_{c})\)</span>到点<span class="math inline">\(P&#39;_{c}(x&#39;_{c},y&#39;_{c},z&#39;_{c})\)</span>的投影模型表示为： <span class="math display">\[\frac{z_{c}}{z&#39;_{c}}=\frac{z_{c}}{f}=-\frac{x_{c}}{x&#39;_{c}}=-\frac{y_{c}}{y&#39;_{c}}\]</span> 将<span class="math inline">\(P&#39;_{c}\)</span>放到对称成像平面上（以后以此替代成像平面），则有： <span class="math display">\[\left\{\begin{matrix}x&#39;_{c} = f \frac{x_{c}}{z_{c}}\\ y&#39;_{c} = f \frac{y_{c}}{z_{c}}\end{matrix}\right.\]</span> 将上式代入像素坐标的变换中，这里<span class="math inline">\(x&#39;_{c}=x&#39;_{i}\)</span>、<span class="math inline">\(y&#39;_{c}=x&#39;_{i}\)</span>，可以得到： <span class="math display">\[\left\{\begin{matrix}u = f_{x} \frac{x_{c}}{z_{c}} + c_{x}\\ v = f_{y} \frac{y_{c}}{z_{c}} + c_{y}\end{matrix}\right.\]</span> 其中，<span class="math inline">\(f_{x}=\frac{1}{\mathrm{d}x} f\)</span>、<span class="math inline">\(f_{y}=\frac{1}{\mathrm{d}y} f\)</span>，<span class="math inline">\(f_{x}\)</span>、<span class="math inline">\(f_{y}\)</span>单位为像素。写成矩阵形式，有： <span class="math display">\[{z_{c}}{P&#39;_{p}}={z_{c}} \begin{bmatrix}u\\ v\\ 1\end{bmatrix} = \begin{bmatrix}\frac{1}{\mathrm{d}x} &amp; 0 &amp; c_{x}\\ 0 &amp; \frac{1}{\mathrm{d}y} &amp; c_{y}\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix}f &amp; 0 &amp; 0\\ 0 &amp; f &amp; 0\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix}x_{c}\\ y_{c} \\ 1\end{bmatrix}=\begin{bmatrix}f_{x} &amp; 0 &amp; c_{x}\\ 0 &amp; f_{y} &amp; c_{y}\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix}x_{c}\\ y_{c} \\ z_{c}\end{bmatrix} =KP_{c}\]</span> 其中，<span class="math inline">\(K\)</span>为相机内参矩阵，相机的内参出厂后是不变的（不要拧动镜头，会影响焦距），可通过标定得到。至此，建立了像素点坐标<span class="math inline">\(P&#39;_{p}(u,v)\)</span>和P在相机坐标系中的点<span class="math inline">\(P_{c}(x_{c},y_{c},z_{c})\)</span>之间的数学关系。</p><h3 id="像素坐标-世界坐标">像素坐标-世界坐标</h3><p>至此，需要建立相机坐标系下<span class="math inline">\(P_{c}(x_{c},y_{c},z_{c})\)</span>和世界坐标系下<span class="math inline">\(P_{w}(x_{w},y_{w},z_{w})\)</span>之间的数学关系，二者是同一点在不同坐标系下的表示，可通过变换矩阵来表示： <span class="math display">\[z_{c}P&#39;_{p}=KP_{c}=K(RP_{w}+t)\]</span> 其中，<span class="math inline">\(R\)</span>为3×3旋转矩阵，<span class="math inline">\(t\)</span>为3×1平移向量，为相机相对世界坐标系的位姿。</p><p>以上等式进行齐次化，将最后一维进行归一化处理，整理得到： <span class="math display">\[z_{c}P&#39;_{p}=z_{c}\begin{bmatrix}u\\ v\\ 1\end{bmatrix} = \begin{bmatrix}f_{x} &amp; 0 &amp; c_{x}\\ 0 &amp; f_{y} &amp; c_{y}\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix}x_{c}\\ y_{c} \\ z_{c}\end{bmatrix} =\begin{bmatrix}f_{x} &amp; 0 &amp; c_{x} &amp; 0\\ 0 &amp; f_{y} &amp; c_{y} &amp; 0\\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}  \begin{bmatrix}R &amp; t \\ \vec{0} &amp; 1\end{bmatrix} \begin{bmatrix}x_{w}\\ y_{w} \\ z_{w} \\ 1\end{bmatrix} =KTP_{w}\]</span> 其中，<span class="math inline">\(T\)</span>为相机外参，即相机坐标系相对世界坐标系的变换矩阵，相机位姿改变，则外参T会随之变化。关于外参，这个主要涉及坐标变换的知识，因为对这一块比较熟悉，因此具体内容略去。至此，在不考虑畸变的情况下，建立了像素坐标系下点<span class="math inline">\(P&#39;_{p}(u,v)\)</span>和世界坐标系下点之间<span class="math inline">\(P_{w}(x_{w},y_{w},z_{w})\)</span>的几何关系。</p><h3 id="归一化相机平面">归一化相机平面</h3><p>在像素坐标-相机坐标的模型中，按照齐次坐标的方式，可以将<span class="math inline">\(z_{c}\)</span>约去，<span class="math inline">\(P_{c}(x_{c},y_{c},z_{c})\)</span>变为<span class="math inline">\(P_{c}(\frac{x_{c}}{z_{c}},\frac{y_{c}}{z_{c}},1)\)</span>，此时得到<span class="math inline">\(P\)</span>在相机归一化平面上的投影，有如下关系： <span class="math display">\[{P&#39;_{p}}=\begin{bmatrix}u\\ v\\ 1\end{bmatrix} = \begin{bmatrix}f_{x} &amp; 0 &amp; c_{x}\\ 0 &amp; f_{y} &amp; c_{y}\\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix}\frac{x_{c}}{z_{c}}\\ \frac{y_{c}}{z_{c}} \\ 1\end{bmatrix} =K \begin{bmatrix}x\\ y \\ 1\end{bmatrix} =KP_{c}\]</span> 这时，可以将<span class="math inline">\(P_{c}(\frac{x_{c}}{z_{c}},\frac{y_{c}}{z_{c}},1)\)</span>看做一个二维点，这里记为<span class="math inline">\(P_{c}(x,y,1)\)</span>，它位于相机前方z=1处的平面上，该平面称为相机归一化平面。</p><h2 id="透镜畸变">透镜畸变</h2><p>畸变包括径向畸变和切向畸变，其中，径向畸变主要由透镜形状引起，有桶形畸变和枕形畸变，由于透镜的加工往往时中心对称的，不规则的畸变通常是径向对称。切向畸变是相机在组装时不能是透镜和成像面严格平行造成的。</p><p>对于径向畸变，可以用与距中心距离有关的二次及高次多项式函数进行纠正，在相机归一化坐标系中，有： <span class="math display">\[\left\{\begin{matrix}x_{d} = x(1 + k_{1}r^2 + k_{2}r^4 + k_{3}r^6)\\ y_{d} = y (1 + k_{1}r^2 + k_{2}r^4 + k_{3}r^6)\end{matrix}\right.\]</span> 其中，<span class="math inline">\(\begin{bmatrix}x, y\end{bmatrix}^T\)</span>是归一化相机平面的坐标，<span class="math inline">\(\begin{bmatrix}x_{d}, y_{d}\end{bmatrix}^T\)</span>是归一化相机平面引入畸变的坐标，<span class="math inline">\(r^2 = x^2+y^2\)</span>。</p><p>对于切向畸变，其纠正方式如下： <span class="math display">\[\left\{\begin{matrix}x_{d} = x + 2p_{1}xy + p_{2}(r^2 + 2x^2)\\ y_{d} = y + p_{1}(r^2 + 2y^2) + 2p_{2}xy\end{matrix}\right.\]</span> 结合径向畸变和切向畸变，可以求出归一化相机坐标系下原始图像的实际坐标： <span class="math display">\[\left\{\begin{matrix}x_{d} = x(1 + k_{1}r^2 + k_{2}r^4 + k_{3}r^6) + 2p_{1}xy + p_{2}(r^2 + 2x^2)\\ y_{d} = y (1 + k_{1}r^2 + k_{2}r^4 + k_{3}r^6) + p_{1}(r^2 + 2y^2) + 2p_{2}xy\end{matrix}\right.\]</span> 两种畸变最后都归结到五个参数：<span class="math inline">\(k_{1}\)</span>、<span class="math inline">\(k_{2}\)</span>、<span class="math inline">\(p_{1}\)</span>、<span class="math inline">\(p_{2}\)</span>、<span class="math inline">\(k_{3}\)</span>，注意，此为OpenCV畸变系数的书写顺序。通过内参矩阵将归一化相机坐标转换到像素平面，得到该点在图像上的正确位置（此时图像是带畸变的）： <span class="math display">\[\left\{\begin{matrix}u_{d} = f_{x} x_{d} + c_{x}\\ v_{d} = f_{y} y_{d} + c_{y}\end{matrix}\right.\]</span> 这里，如果拿到了带畸变的图像再去畸变，则是要通过带畸变的<span class="math inline">\(\begin{bmatrix}u_{d}, v_{d}\end{bmatrix}^T\)</span>得到去畸变的<span class="math inline">\(\begin{bmatrix}u, v\end{bmatrix}^T\)</span>，这是以上推导的逆过程，即是通过<span class="math inline">\(\begin{bmatrix}u_{d}, v_{d}\end{bmatrix}^T\)</span>反求<span class="math inline">\(\begin{bmatrix}x_{d}, y_{d}\end{bmatrix}^T\)</span>，然后通过迭代的方式求解<span class="math inline">\(\begin{bmatrix}x, y\end{bmatrix}^T\)</span>，可参考OpenCV去畸变迭代解法，最后通过内参矩阵将归一化相机坐标转换到像素平面，得到去畸变的<span class="math inline">\(\begin{bmatrix}u, v\end{bmatrix}^T\)</span>，有： <span class="math display">\[\left\{\begin{matrix}u = f_{x} x + c_{x}\\ v = f_{y} y + c_{y}\end{matrix}\right.\]</span></p><h1 id="相机标定">相机标定</h1><p>相机标定的目的有2个：</p><ul><li>第一个目的就是获得相机的内参矩阵<span class="math inline">\(K\)</span>和外参矩阵<span class="math inline">\(T\)</span>，其中，<span class="math inline">\(K\)</span>是固定不变的，<span class="math inline">\(T\)</span>会随着相机位姿变换而改变。</li><li>第二个目的就是获得相机的畸变系数：<span class="math inline">\(k_{1}\)</span>、<span class="math inline">\(k_{2}\)</span>、<span class="math inline">\(p_{1}\)</span>、<span class="math inline">\(p_{2}\)</span>、<span class="math inline">\(k_{3}\)</span>。</li></ul><p>在张正友标定中，从不同角度拍15-20张棋盘格照片，就可以求解相机的内参、外参和畸变系数。</p><h2 id="棋盘格标定板">棋盘格标定板</h2><p>平面的单应性被定义为从一个平面到另一个平面的投影映射，下图中的二维平面上的棋盘格角点映射到相机成像仪上的映射就是平面单应性的例子。假定世界坐标系原点在标定板第一个角点，此时，物理世界的点<span class="math inline">\(P_{w}(x_{w},y_{w},0)\)</span>通过投影映射到像素坐标<span class="math inline">\(P&#39;_{p}(u,v)\)</span>。</p><p>已知条件：已知棋盘格实际大小尺寸，如12×9格、每格30mm，就知道物理世界中角点的世界坐标；通过相机成像拿到图像，再通过角点检测算法检测角点，就知道与物理世界对应的角点的像素坐标。</p><img src="/skill/model_of_camera_imaging_and_camera_Calibration/image-20210407185718580.png" class="" title="image-20210407185718580"><h2 id="单应性矩阵">单应性矩阵</h2><p>由上述推导可知，不考虑畸变，对于世界坐标系单点<span class="math inline">\(P_{w}(x_{w},y_{w},z_{w})\)</span>投影到像素坐标系中<span class="math inline">\(P&#39;_{p}(u,v)\)</span>，令<span class="math inline">\(z_{w}=0\)</span>，稍作调整，其数学模型如下： <span class="math display">\[s P’_{p}=s\begin{bmatrix}u\\ v\\ 1\end{bmatrix} = \begin{bmatrix}f_{x} &amp; \gamma &amp; c_{x}\\ 0 &amp; f_{y} &amp; c_{y}\\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix}r_{1} &amp; r_{2} &amp; r_{3} &amp; t \end{bmatrix} \begin{bmatrix}x_{w}\\ y_{w} \\ 0 \\ 1\end{bmatrix} =K\begin{bmatrix}r_{1} &amp; r_{2} &amp; t \end{bmatrix} \begin{bmatrix}x_{w}\\ y_{w} \\ 1\end{bmatrix} =KTP_{w}\]</span> 其中，<span class="math inline">\(s\)</span>为尺度因子，<span class="math inline">\(\gamma\)</span>为考虑传感器的横边和纵边之间的角度误差（角度为90°表示无误差，此时<span class="math inline">\(\gamma\)</span>=0），上式中可忽略<span class="math inline">\(r_{3}\)</span>。令<span class="math inline">\(H=K\begin{bmatrix}r_{1} &amp; r_{2} &amp; t \end{bmatrix}\)</span>，则有 <span class="math display">\[s P’_{p}=s\begin{bmatrix}u\\ v\\ 1\end{bmatrix} = \begin{bmatrix}H_{11} &amp; H_{12} &amp; H_{13}\\ H_{21} &amp; H_{22} &amp; H_{23}\\ H_{31} &amp; H_{32} &amp; H_{33} \end{bmatrix} \begin{bmatrix}x_{w}\\ y_{w} \\ 1\end{bmatrix} =HP_{w}\]</span> 上式中，单点<span class="math inline">\(P_{w}\)</span>和<span class="math inline">\(P&#39;_{p}\)</span>是已知的，则根据已知点坐标求解<span class="math inline">\(H\)</span>，<span class="math inline">\(H\)</span>称为单应性矩阵。展开方程消去尺度因子<span class="math inline">\(s\)</span>、<span class="math inline">\(\lambda\)</span>，得到 <span class="math display">\[\left\{\begin{matrix}H_{33}u = H_{11} x_{w} + H_{12} y_{w} + H_{13} - H_{31} x_{w}u - H_{32} y_{w}u\\ H_{33}v = H_{11} x_{w} + H_{12} y_{w} + H_{13} - H_{31} x_{w}v - H_{32} y_{w}v\end{matrix}\right.\]</span> 上式中，一个点对提供两个约束方程。<span class="math inline">\(H\)</span>为齐次矩阵，可成倍放大或缩小，共8个独立元素，令<span class="math inline">\(H_{33}=1\)</span>或者令矩阵模变为1，通过单张棋盘格照片中的4个角点可以提供8个约束方程，通过线性方程求解的方法称为直接线性变换法。当一张图片上的标定板角点数量大于4时，利用最小二乘法回归最佳的矩阵 <span class="math inline">\(H\)</span>，每张照片对应一个<span class="math inline">\(H\)</span>。至此，完成<span class="math inline">\(H\)</span>的求解（<strong>注意：这里求得的<span class="math inline">\(H\)</span>最后一个元素进行了归一化，实际的<span class="math inline">\(H\)</span>是带尺度因子的，后面涉及到<span class="math inline">\(H\)</span>的表示时不加尺度因子，但是计算需要加上尺度因子</strong>）。</p><h2 id="内参的求解">内参的求解</h2><p>在求得单应性矩阵<span class="math inline">\(H\)</span>的基础上，进一步求取内参。可知旋转矩阵<span class="math inline">\(R\)</span>为单位正交矩阵，满足以下关系： <span class="math display">\[\left\{\begin{matrix}r_{1}^Tr_{2}=0\\ r_{1}^Tr_{1} = r_{2}^Tr_{2} = 1\end{matrix}\right.\]</span> 同时，根据<span class="math inline">\(H\)</span>的定义，令<span class="math inline">\(H=\begin{bmatrix}H_{1} &amp; H_{2} &amp; H_{3} \end{bmatrix}=K\begin{bmatrix}r_{1} &amp; r_{2} &amp; t \end{bmatrix}\)</span>，可以得到： <span class="math display">\[\left\{\begin{matrix}r_{1}=K^{-1}H_{1}\\ r_{2}=K^{-1}H_{2}\end{matrix}\right.\]</span> 结合以上二式，通过<span class="math inline">\(r_{1}\)</span>、$ r_{2}$单位正交得到的约束方程，则有： <span class="math display">\[\left\{\begin{matrix}H_{1}^T B H_{2} = 0\\ H_{1}^T B H_{1} = H_{2}^T B H_{2} = 1\end{matrix}\right.\]</span> 其中，<span class="math inline">\(B=K^{-T} K^{-1}\)</span>，B为对称矩阵，共6个元素。按照内参矩阵展开得到<span class="math inline">\(B\)</span>： <span class="math display">\[B = K^{-T} K^{-1} =\begin{bmatrix}\frac{1}{f_{x}^2} &amp; -\frac{\gamma}{f_{x}^2f_{y}} &amp; \frac{\gamma c_{y}-f_{y}c_{x}}{f_{x}^2f_{y}} \\ -\frac{\gamma}{f_{x}^2f_{y}} &amp; \frac{1}{f_{y}^2} + \frac{\gamma^2}{f_{x}^2f_{y}^2} &amp; \frac{\gamma (f_{y}c_{x}-\gamma c_{y})}{f_{x}^2f_{y}^2}-\frac{c_{y}}{f_{y}^2} \\ \frac{\gamma c_{y} -f_{y}c_{x}}{f_{x}^2f_{y}} &amp; \frac{\gamma(f_{y}c_{x} -\gamma c_{y})}{f_{x}^2f_{y}^2}-\frac{c_{y}}{f_{y}^2} &amp; \frac{(f_{y}c_{x}-\gamma c_{y})^2}{f_{x}^2f_{y}^2}+\frac{c_{y}^2}{f_{y}^2}+1 \end{bmatrix} =\begin{bmatrix}B_{11} &amp; B_{12} &amp; B_{13} \\ B_{12} &amp; B_{22}&amp; B_{23} \\ B_{13} &amp; B_{23} &amp; B_{33} \end{bmatrix}\]</span> 为了求解矩阵<span class="math inline">\(B\)</span>，需要计算<span class="math inline">\(H_{i}^TBH_{j}^T\)</span> ： <span class="math display">\[H_{i}^TBH_{j}^T=\begin{bmatrix}H_{1i} &amp; H_{2i} &amp; H_{3i} \end{bmatrix}    \begin{bmatrix}B_{11} &amp; B_{12} &amp; B_{13} \\ B_{12} &amp; B_{22}&amp; B_{23} \\ B_{13} &amp; B_{23} &amp; B_{33} \end{bmatrix}    \begin{bmatrix}H_{1i} \\ H_{2i} \\ H_{3i} \end{bmatrix}=v_{ij}b\]</span></p><p>其中，<span class="math inline">\(v_{ij}\)</span>、<span class="math inline">\(b\)</span>分别记为： <span class="math display">\[v_{ij} = \begin{bmatrix}H_{1i}H_{1j} &amp; H_{1i}H_{2j}+H_{2i}H_{1j} &amp; H_{2i}H_{2j} &amp; H_{1i}H_{3j}+H_{3i}H_{1j} &amp; H_{2i}H_{3j}+H_{3i}H_{2j} &amp; H_{3i}H_{3j}\end{bmatrix}^T\]</span></p><p><span class="math display">\[b = \begin{bmatrix}B_{11} &amp; B_{12} &amp; B_{22} &amp; B_{13} &amp; B_{23} &amp; B_{33}\end{bmatrix}^T\]</span></p><p>此时，通过<span class="math inline">\(r_{1}\)</span>、$ r_{2}$单位正交得到的约束方程可化为： <span class="math display">\[\begin{bmatrix}v_{12}^T \\ v_{11}^T -v_{22}^T \end{bmatrix} b =vb =0\]</span> 矩阵<span class="math inline">\(v\)</span>全部由单应性矩阵<span class="math inline">\(H\)</span>的元素构成，因此矩阵<span class="math inline">\(v\)</span>已知，每个<span class="math inline">\(H\)</span>对应一个<span class="math inline">\(v\)</span>，因为内参不变，所以处在每个位姿的相机可以提供一个<span class="math inline">\(v\)</span>。<span class="math inline">\(b\)</span>中有6个独立元素，每个<span class="math inline">\(v\)</span>可构成两个约束方程，所以最少需要3张不同位姿的照片才能求解向量<span class="math inline">\(b\)</span>。当棋盘格图片的个数大于3时（事实上一般需要15到20张标定板图片），可采用最小二乘拟合最佳的向量 <span class="math inline">\(b\)</span>，并得到矩阵 <span class="math inline">\(B\)</span>，可以计算内参矩阵<span class="math inline">\(K\)</span>中每个元素。</p><p>考虑单应性矩阵<span class="math inline">\(H\)</span>带有尺度因子，<span class="math inline">\(B\)</span>由<span class="math inline">\(H\)</span>中的元素构成，这里引入尺度因子<span class="math inline">\(\lambda\)</span>进行矫正： <span class="math display">\[B=\lambda K^{-T} K^{-1}\]</span> 通过最终解算，可以得到： <span class="math display">\[\begin{matrix}c_{y} = (B_{12}B_{13}-B_{11}B_{23})/(B_{11}B_{22}-B_{12}^2)\\\lambda = B_{33} - [B_{13}^2+c_{y}(B_{12}B_{13}-B_{11}B_{23})]/{B_{11}}\\  f_{x} = \sqrt{\lambda/B_{11}}\\  f_{y} = \sqrt{\lambda B_{11}/(B_{11}B_{22}-B_{12}^2)} \\  \gamma = -B_{12}f_{x}^2f_{y}/\lambda \\ c_{x} = \gamma c_{y}/f_{x} - B_{13}f_{x}^2/\lambda\end{matrix}\]</span> 至此，完成内参矩阵<span class="math inline">\(K\)</span>的求解。</p><h2 id="外参的求解">外参的求解</h2><p>在求得单应性矩阵<span class="math inline">\(H\)</span>和内参矩阵<span class="math inline">\(K\)</span>的基础上，结合<span class="math inline">\(H=K\begin{bmatrix}r_{1} &amp; r_{2} &amp; t \end{bmatrix}\)</span>和<span class="math inline">\(T=\begin{bmatrix}r_{1} &amp; r_{2} &amp; r_{3} &amp; t \end{bmatrix}\)</span>，<span class="math inline">\(r_{1}\)</span>、<span class="math inline">\(r_{2}\)</span>、<span class="math inline">\(t\)</span>可以求解，考虑单应性矩阵<span class="math inline">\(H\)</span>带有尺度因子，引入尺度因子<span class="math inline">\(\hat{\lambda}\)</span>进行矫正： <span class="math display">\[\left\{\begin{matrix}r_{1} = \hat{\lambda} A^{-1} H_{1}\\ r_{2} = \hat{\lambda} A^{-1} H_{2}\\ t = \hat{\lambda} A^{-1} H_{3}\end{matrix}\right.\]</span> 根据上式可以求得这里的尺度因子<span class="math inline">\(\hat{\lambda}\)</span>： <span class="math display">\[\hat{\lambda} = \frac{1}{||A^{-1}H_{1}||} = \frac{1}{||A^{-1}H_{2}||}\]</span> 利用旋转矩阵的向量单位正交的特性，得到<span class="math inline">\(r_{3}\)</span>： <span class="math display">\[r_{3} = r_{1}\times r_{2}\]</span> 至此，完成外参矩阵<span class="math inline">\(T\)</span>的求解。</p><h2 id="畸变系数的求解">畸变系数的求解</h2><p>在不考虑畸变的情况下，以上求解可得到相机的内、外参，但是，实际中透镜引入的畸变会导致实际成像失真，而我们拍出来不做处理的图片是带有畸变的。假设理论无畸变像素<span class="math inline">\(\begin{bmatrix}u, v\end{bmatrix}^T\)</span>，实际的像素坐标<span class="math inline">\(\begin{bmatrix}u_{d}, v_{d}\end{bmatrix}^T\)</span>，理论无畸变归一化点坐标<span class="math inline">\(\begin{bmatrix}x, y\end{bmatrix}^T\)</span>，实际的归一化点坐标<span class="math inline">\(\begin{bmatrix}x_{d}, y_{d}\end{bmatrix}^T\)</span>，则有：</p><p><span class="math display">\[\begin{matrix}\left\{\begin{matrix}u = f_{x} x + c_{x}\\ v = f_{y} y + c_{y}\end{matrix}\right. &amp;  \left\{\begin{matrix}u_{d} = f_{x} x_{d} + c_{x}\\ v_{d} = f_{y} y_{d} + c_{y}\end{matrix}\right.\end{matrix}\]</span> 在张正友标定中，只考虑了影响畸变较大的径向畸变系数<span class="math inline">\(k_{1}\)</span>、<span class="math inline">\(k_{2}\)</span>，如下： <span class="math display">\[\left\{\begin{matrix}x_{d} = x(1 + k_{1}r^2 + k_{2}r^4)\\ y_{d} = y (1 + k_{1}r^2 + k_{2}r^4)\end{matrix}\right.\]</span> 结合以上二式，可以得到 <span class="math display">\[\begin{bmatrix}(u-c_{x})(x^{2}+y^{2}) &amp; (u-c_{x})(x^{2}+y^{2})^{2} \\ (v-c_{y})(x^{2}+y^{2}) &amp; (v-c_{y})(x^{2}+y^{2})^{2} \end{bmatrix}     \begin{bmatrix} k_{1} \\ k_{2}\end{bmatrix} = \begin{bmatrix} u_{d}-c_{x} \\ u_{d}-c_{x}\end{bmatrix}\]</span> 对于每一个角点，只要知道畸变后的像素坐标<span class="math inline">\(\begin{bmatrix}u_{d}, v_{d}\end{bmatrix}^T\)</span>、理想的无畸变的像素坐标<span class="math inline">\(\begin{bmatrix}u, v\end{bmatrix}^T\)</span>，<span class="math inline">\(\begin{bmatrix}x, y\end{bmatrix}^T\)</span>也可以经过内参解算出来，就可以构造两个上述约束方程，需要求解未知数<span class="math inline">\(k_{1}\)</span>、<span class="math inline">\(k_{2}\)</span>。那么，有n幅图像，每幅图像上有m个标定板角点，可以得到2mn个约束方程，将约束方程系数矩阵记为<span class="math inline">\(D\)</span>，等式右端非齐次项记为<span class="math inline">\(d\)</span>，可将其记着矩阵形式： <span class="math display">\[Dk=d\]</span> 这里可以用最小二乘法求解，最小二乘法的目标：求误差的最小平方和，根据代价函数的对应有两种：线性和非线性（<strong>取决于对应的残差(residual)是线性的还是非线性的</strong>）。非线性最小二乘没有封闭解，通常用迭代法求解；线性最小二乘的解是封闭解，如果x使<span class="math inline">\(||Dx-d||\)</span>最小化，则x满足正规系方程<span class="math inline">\(D^{T}Dx = D^{T}d\)</span>，<span class="math inline">\(k\)</span>的<strong>线性最小二乘解</strong>可由下式给出： <span class="math display">\[k= \begin{bmatrix} k_{1} \\ k_{2}  \end{bmatrix} =(D^{T}D)^{−1} D^{T}d\]</span> 其中，内参、外参已知，<span class="math inline">\(\begin{bmatrix}u_{d}, v_{d}\end{bmatrix}^T\)</span>可以从拍到的原始照片中获取，<span class="math inline">\(\begin{bmatrix}u, v\end{bmatrix}^T\)</span>可以通过反投影近似求得，如下所示： <span class="math display">\[s\begin{bmatrix}u\\ v\\ 1\end{bmatrix} = K\begin{bmatrix}r_{1} &amp; r_{2} &amp; t \end{bmatrix} \begin{bmatrix}x_{w}\\ y_{w} \\ 1\end{bmatrix} =H \begin{bmatrix}x_{w}\\ y_{w} \\ 1\end{bmatrix}\]</span> 在上式的基础上，消去尺度因子<span class="math inline">\(s\)</span>，此处将<span class="math inline">\(H\)</span>中的尺度因子也算到<span class="math inline">\(s\)</span>中，可得： <span class="math display">\[\left\{\begin{matrix}u = \frac{H_{11} x_{w} + H_{12} y_{w} + H_{13}}{H_{31} x_{w} + H_{32} y_{w} + H_{33}}\\ v = \frac{H_{21} x_{w} + H_{22} y_{w} + H_{23}}{H_{31} x_{w} + H_{32} y_{w} + H_{33}}\end{matrix}\right.\]</span> 至此，便可以求出畸变系数<span class="math inline">\(k_{1}\)</span>、<span class="math inline">\(k_{2}\)</span>。</p><p><strong>这里有一个疑问，我的理解是这样的。实际拿到的照片是带有畸变的，但是在计算内、外参是使用的是无畸变像素像素坐标，这时，求得的内、外参是不是准确的。同时，求解畸变系数时需要提供带畸变和无畸变的像素坐标，而无畸变的像素坐标是使用在上一过程中的内、外参矩阵间接反投影得到的。反求的无畸变像素坐标和上一过程使用的不一样，因为内、外参矩阵是综合很多角点优化得到的。因此，再通过迭代求解对参数进行优化。</strong></p><h2 id="极大似然估计">极大似然估计</h2><p>通过理想无畸变像素求出初始内、外参后，根据内外、参可以得到物理世界点重新投影在成像平面后的像素坐标<span class="math inline">\(\hat{P&#39;}\)</span>。假设我们有棋盘格模型的n个图像，模型平面上有m个点，且图像上的噪声服从独立同一分布，令第i副图像上的角点<span class="math inline">\((P_{w})_{j}\)</span>在重投影得到的点<span class="math inline">\(\hat{P&#39;}\)</span>： <span class="math display">\[\hat{P&#39;}(K,R_{i},t_{i},(P_{w})_{j})=K[R,t] (P_{w})_{j}\]</span> 其中，<span class="math inline">\(K\)</span>——相机内参，<span class="math inline">\(R_{i}\)</span>——第i张图像的旋转矩阵，<span class="math inline">\(t_{i}\)</span>——第i张图像的平移向量，<span class="math inline">\((P_{w})_{j}\)</span>——第j个角点对应的世界坐标。则角点<span class="math inline">\(P&#39;_{ij}\)</span>的概率密度函数为： <span class="math display">\[f(P&#39;_{ij})=\frac{1}{\sqrt{2\pi}}e^{-\frac{(P&#39;_{ij}-\hat{P&#39;}(K,R_{i},t_{i},(P_{w})_{j})^2}{\sigma^2}}\]</span> 构造最大似然估计： <span class="math display">\[L(P&#39;_{ij}-\hat{P&#39;}(K,R_{i},t_{i},(P_{w})_{j})=\prod_{i=1,j=1}^{n,m}f(P&#39;_{ij})=\frac{1}{\sqrt{2\pi}}e^{-\frac{\sum_{i=1}^{n}\sum_{j=1}^{m}(P&#39;_{ij}-\hat{P&#39;}(K,R_{i},t_{i},(P_{w})_{j})^2}{\sigma^2}}\]</span></p><p>使用最小化负对数的方式来求高斯分布的最大似然，则最大似然估计可以通过最小化以下函数得到： <span class="math display">\[\sum_{i=1}^{n}\sum_{j=1}^{m}=\left \| P&#39;_{ij}-\hat{P&#39;}(K,R_{i},t_{i},(P_{w})_{j}) \right \|^2\]</span> 上式中，<span class="math inline">\(P&#39;_{ij}\)</span>——通过角点检测算法得到的第i张图像的第j个角点像素坐标。</p><p>那么，怎么令上面这个目标函数达到最小值呢？可以看出，这是一个<strong>非线性最小二乘</strong>问题，目的是通过估计参数<span class="math inline">\((K,R_{i},t_{i},P_{wj})\)</span>使重投影误差最小，可以通过列文伯格-马夸尔特方法（L-M方法）求解参数。关于L-M算法的具体内容，可在Matlab中进行验证，也可以利用ceres库和g2o库等工具构建，这里先不作叙述。</p><p>考虑畸变的影响时，新引入了两个参数<span class="math inline">\(k_{1}\)</span>、<span class="math inline">\(k_{2}\)</span>，则极大似然估计可以通过最小化以下函数得到： <span class="math display">\[\sum_{i=1}^{n}\sum_{j=1}^{m}=\left \| P&#39;_{ij}-\hat{P&#39;}(K,k_{1},k_{2},R_{i},t_{i},(P_{w})_{j}) \right \|^2\]</span> 因此，整个过程两次使用极大似然估计优化参数，第一次用来优化内、外参，使用优化的内、外参求解畸变系数，最后再一起优化内、外参和畸变系数。</p><h2 id="相机标定的步骤">相机标定的步骤</h2><p>总结以上过程，标定的简要步骤如下：</p><ol type="1"><li>准备一个张正友标定法的棋盘格，棋盘格大小已知，用相机对其进行不同角度的拍摄，得到一组15-20张图像；</li><li>对图像中的特征点如标定板角点进行检测，得到标定板角点的像素坐标值，根据已知的棋盘格大小和世界坐标系原点，计算得到标定板角点的物理坐标值；</li><li>求解内参矩阵与外参矩阵。根据物理坐标值和像素坐标值的关系，求出单应性矩阵<span class="math inline">\(H\)</span>，进而构造<span class="math inline">\(v\)</span>矩阵，求解<span class="math inline">\(B\)</span>矩阵，利用<span class="math inline">\(B\)</span>矩阵求解相机内参矩阵 <span class="math inline">\(K\)</span>，最后求解每张图片对应的相机外参矩阵 <span class="math inline">\(T\)</span>（旋转矩阵<span class="math inline">\(R\)</span>和平移向量<span class="math inline">\(t\)</span>），通过极大似然估计优化内、外参；</li><li>求解畸变参数。利用构造<span class="math inline">\(D\)</span>矩阵，计算径向畸变参数；</li><li>综合内外参、畸变系数，利用极大似然估计对这些参数进行优化。</li></ol><h1 id="代码">代码</h1><p>基于张正友标定相机内参，详见C++实现代码<a href="%5Blizhengsi/zhangCalibration%20(github.com)%5D(https://github.com/lizhengsi/zhangCalibration)">zhangCalibration</a></p><h1 id="参考">参考</h1><ul><li>A Flexible New Technique for Camera Calibration, zhang</li><li>https://zhuanlan.zhihu.com/p/94244568</li><li>学习Opencv，Gary Bradski &amp; Adrian Kaebler</li><li>视觉SLAM十四讲，高翔</li><li>https://www.cnblogs.com/mtcnn/p/9411941.html</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;张正友标定法是基于单平面棋盘格的相机标定方法，由张正友博士在1998年的论文：&quot;A Flexible New Technique for Camera Calibration&quot;中提出，该方法介于传统的标定方法和自标定方法之间，使用简单实用性强，克服了传统标定法需要的高精度标定物的缺点，而仅需使用一个打印出来的棋盘格即可，便于操作，因此，广泛用于计算机视觉领域。&lt;/p&gt;</summary>
    
    
    
    <category term="问术" scheme="https://lizhengsi.github.io/categories/skill/"/>
    
    
    <category term="相机模型" scheme="https://lizhengsi.github.io/tags/camera-model/"/>
    
    <category term="张正友标定" scheme="https://lizhengsi.github.io/tags/zhang-s-method-of-calibration/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo搭建个人博客</title>
    <link href="https://lizhengsi.github.io/skill/Build_a_personal_blog_based_on_Hexo/"/>
    <id>https://lizhengsi.github.io/skill/Build_a_personal_blog_based_on_Hexo/</id>
    <published>2018-02-27T12:19:45.000Z</published>
    <updated>2021-05-30T11:19:22.865Z</updated>
    
    <content type="html"><![CDATA[<p>如果你要搭建个人博客网站，更注重内容的输出，而不是把时间花在网站的维护上，那么，通过Hexo来构建个人博客网站是一个很不错的选择。</p><a id="more"></a><h1 id="前言">前言</h1><p><a href="https://hexo.io/zh-cn/">Hexo</a> 是一个基于 <a href="https://nodejs.org/">Node.js</a>的快速、简洁且高效的博客框架，通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html">标签插件</a> 来快速的插入特定形式的内容。</p><h1 id="准备工作">准备工作</h1><p>准备工作主要配置相关环境和基本要求，新手建议在安装或注册账号时先使用搜索引擎了解详细的安装配置方法，避免后续出错。</p><h2 id="github账号">GitHub账号</h2><p>如没有使用过GitHub，前往<a href="https://github.com/">GitHub</a>注册一个账号，并了解下GitHub基本信息 ，此处省略...</p><h2 id="安装git">安装git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a> 。</li><li>Mac：使用 Homebrew, MacPorts ：<code>brew install git</code>;或下载 安装程序 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li></ul><p>检验是否安装成功： <code>$ git version</code></p><h2 id="安装node.js">安装Node.js</h2><p>去 <a href="https://nodejs.org/en/download/">Node.js</a> 官网下载所需系统的安装包，并根据提示安装即可。Node.js版本及对应的hexo版本如下：</p><table><thead><tr class="header"><th style="text-align: left;">Hexo 版本</th><th style="text-align: left;">最低兼容 Node.js 版本</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">5.0+</td><td style="text-align: left;">10.13.0</td></tr><tr class="even"><td style="text-align: left;">4.1 - 4.2</td><td style="text-align: left;">8.10</td></tr><tr class="odd"><td style="text-align: left;">4.0</td><td style="text-align: left;">8.6</td></tr><tr class="even"><td style="text-align: left;">3.3 - 3.9</td><td style="text-align: left;">6.9</td></tr><tr class="odd"><td style="text-align: left;">3.2 - 3.3</td><td style="text-align: left;">0.12</td></tr><tr class="even"><td style="text-align: left;">3.0 - 3.1</td><td style="text-align: left;">0.10 or iojs</td></tr><tr class="odd"><td style="text-align: left;">0.0.1 - 2.8</td><td style="text-align: left;">0.10</td></tr></tbody></table><p>检验是否安装成功： <code>$ node -v</code></p><h2 id="安装hexo">安装hexo</h2><p>上述两个必备程序安装成功之后，只需要通过npm便可以完成Hexo的安装了。 <code>$ npm install -g hexo-cli</code> 至此，完成环境配置。</p><h1 id="本地部署">本地部署</h1><h2 id="本地初始化">本地初始化</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h2 id="本地目录结构">本地目录结构</h2><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds&#x2F;</span><br><span class="line">├── source&#x2F;</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes&#x2F;</span><br></pre></td></tr></table></figure><ul><li>_config.yml</li></ul><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><ul><li>package.json</li></ul><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package.json&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>scaffolds</li></ul><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><ul><li>source</li></ul><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><ul><li>themes</li></ul><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h2 id="启动本地服务">启动本地服务</h2><p>在指定文件夹下，执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g   &#x2F;&#x2F;或者hexo generate </span><br><span class="line">hexo s   &#x2F;&#x2F;或者hexo server，可以在http:&#x2F;&#x2F;localhost:4000&#x2F; 查看</span><br></pre></td></tr></table></figure><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容。到这里，本地的一些基本部署就基本完成了，接下来将本地部署推送至github，并通过访问github静态页面显示。</p><h1 id="远程部署">远程部署</h1><h2 id="创建仓库">创建仓库</h2><p>新建一个名为<code>username.github.io</code>的仓库，创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里。</p><h2 id="绑定域名">绑定域名</h2><h2 id="配置ssh-key">配置SSH key</h2><p>首先在本地创建<code>ssh key</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure><p>后面的<code>your_email@youremail.com</code>改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在<code>~/</code>(windows路径：/c/Users/username/)下生成<code>.ssh</code>文件夹，进去，打开<code>id_rsa.pub</code>，复制里面的<code>key</code>。</p><p>回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。</p><p>为了验证是否成功，在git bash下输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果是第一次的会提示是否continue，输入yes就会看到：You've successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。</p><p>接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;your name&quot;</span><br><span class="line">$ git config --global user.email &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure><h2 id="远程推送">远程推送</h2><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改配置本地配置文件_config.yml。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>其中， <code>hexo clean</code>清除了你之前生成的东西，也可以不加。 <code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写。</p><p><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写。</p><p>现在，在浏览器中输入<code>username.github.io</code>，便可以打开网页了。接下来，需要对hexo进行基本配置和主题配置。</p><h1 id="配置">配置</h1><h2 id="基本配置">基本配置</h2><p>这部分网上有很多写的比较好的，详见附录参考。</p><h2 id="主题配置">主题配置</h2><p>Hexo提供多种主题配置，参见<a href="https://hexo.io/themes/">hexo官网</a>主题界面，这里配置的是<a href="http://theme-next.iissnan.com/">Next主题</a>，简洁才是最美的。在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为 <strong>站点配置文件</strong>， 后者称为 <strong>主题配置文件</strong>。Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。</p><h3 id="下载主题">下载主题</h3><p>如果你熟悉 <a href="http://git-scm.com/">Git</a>， 建议你使用 克隆最新版本 的方式，之后的更新可以通过 <code>git pull</code> 来快速更新， 而不用再次下载压缩包替换。</p><ul><li><a href="http://theme-next.iissnan.com/getting-started.html#clone">克隆最新版本</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html#stable">下载稳定版本</a></li></ul><p>在终端窗口下，定位到 Hexo 站点目录下。使用 <code>Git</code> checkout 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><h3 id="启用主题">启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 <strong>站点配置文件</strong>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><p>启用 NexT 主题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题">验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p><p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p><img src="/skill/Build_a_personal_blog_based_on_Hexo/validation-default-scheme-mac.png" class="" title="img"><p>现在，你已经成功安装并启用了 NexT 主题。下一步我们将要更改一些主题的设定，包括个性化以及集成第三方服务。</p><h3 id="文件组成">文件组成</h3><p>包含主题文件，整个hexo文件结构目录如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">├──</span> <span class="string">.deploy_git/</span><span class="comment">#远程部署</span></span><br><span class="line"><span class="string">├──</span> <span class="string">node_modules/</span><span class="comment">#第三方插件</span></span><br><span class="line"><span class="string">├──</span> <span class="string">public/</span><span class="comment">#html源码，hexo g生成</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scaffolds/</span><span class="comment">#模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">draft.md</span><span class="comment">#草稿</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">page.md</span><span class="comment">#页面</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">post.md</span><span class="comment">#文章</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source/</span><span class="comment">#个人资源</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_posts/</span><span class="comment">#存放个人文章</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">about/</span><span class="comment">#后面是一些自定义文件夹</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">categories/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">life/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">reading/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">skill/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">tags/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">Tao/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">themes/</span><span class="comment">#主题</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">landscape/</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">next/</span><span class="comment">#next主题</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">languages/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">layout/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">scripts/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">source/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">test/</span></span><br><span class="line"><span class="string">|</span>       <span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">|</span>       <span class="string">└──_config.yml</span><span class="comment">#主题配置文件</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">└──</span> <span class="string">_config.yml</span><span class="comment">#站点配置文件</span></span><br></pre></td></tr></table></figure><p>Next主题目录如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">├──</span> <span class="string">.github</span>                <span class="comment">#github信息</span></span><br><span class="line"><span class="string">├──</span> <span class="string">languages</span>              <span class="comment">#多语言</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_en.yml</span>            <span class="comment">#默认语言</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">zh-CN.yml</span>          <span class="comment">#简体中文</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">zh-TW.yml</span>          <span class="comment">#繁体中文</span></span><br><span class="line"><span class="string">├──</span> <span class="string">layout</span>                 <span class="comment">#布局，根目录下的*.swig文件是对主页，分页，存档等的控制</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_custom</span>            <span class="comment">#可以自定义的模板，覆盖原有模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">head.swig</span>      <span class="comment">#文首样式</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">header.swig</span>    <span class="comment">#头部样式</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">sidebar.swig</span>   <span class="comment">#侧边栏样式</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_macro</span>             <span class="comment">#可以自定义的模板，覆盖原有模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">post.swig</span>      <span class="comment">#文章模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">reward.swig</span>    <span class="comment">#打赏模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">sidebar.swig</span>   <span class="comment">#侧边栏模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_partial</span>           <span class="comment">#局部的布局</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">head</span>           <span class="comment">#头部模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">search</span>         <span class="comment">#搜索模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">share</span>          <span class="comment">#分享模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_script</span>            <span class="comment">#局部的布局</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_third-party</span>       <span class="comment">#第三方模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">_layout.swig</span>       <span class="comment">#主页面模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">index.swig</span>         <span class="comment">#主页面模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">page</span>               <span class="comment">#页面模板</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">tag.swig</span>           <span class="comment">#tag模板</span></span><br><span class="line"><span class="string">├──</span> <span class="string">scripts</span>                <span class="comment">#script源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">tags</span>               <span class="comment">#tags的script源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">marge.js</span>           <span class="comment">#页面模板</span></span><br><span class="line"><span class="string">├──</span> <span class="string">source</span>                 <span class="comment">#源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">css</span>                <span class="comment">#css源码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">_common</span>        <span class="comment">#*.styl基础css</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">├──</span> <span class="string">_custom</span>        <span class="comment">#*.styl自定义局部css</span></span><br><span class="line"><span class="string">|</span>   <span class="string">|</span>   <span class="string">└──</span> <span class="string">_mixins</span>        <span class="comment">#mixins的css</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">fonts</span>              <span class="comment">#字体</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">images</span>             <span class="comment">#图片</span></span><br><span class="line"><span class="string">|</span>   <span class="string">├──</span> <span class="string">js</span>                 <span class="comment">#javascript源代码</span></span><br><span class="line"><span class="string">|</span>   <span class="string">└──</span> <span class="string">lib</span>                <span class="comment">#引用库</span></span><br><span class="line"><span class="string">├──</span> <span class="string">_config.yml</span>            <span class="comment">#主题配置文件</span></span><br><span class="line"><span class="string">└──</span> <span class="string">README.md</span>              <span class="comment">#说明文件</span></span><br></pre></td></tr></table></figure><p>可以根据自己的需要进行适当修改。</p><h3 id="选项配置">选项配置</h3><p>在配置Next主题时一些细节已经遗忘，主要是参照参考项中一些博客，可根据个人需求进行配置，以下简单列举在配置主题时的一些设置项：</p><ul><li><p>页面&amp;菜单布局</p><p>采用Next主题中的Gemini布局，菜单栏在侧栏，主题配置文件如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure><p>菜单中含几个类别，我想把不同的文章归类在不同类别下显示，总的目录是categories/，比如新建一个类别skill，则在主题配置文件中修改如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">skill:</span> <span class="string">/categories/skill/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-arrow-down</span></span><br></pre></td></tr></table></figure><p>在-CN.yml文件中修改中文映射，这样在主页时就会按映射的中文显示</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">skill:</span> <span class="string">问术</span></span><br></pre></td></tr></table></figure><p>然后在根目录，并在该目录生成文件index.md</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: 问术</span><br><span class="line">layout: &quot;skill&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure><p>这样，点击主页的“问术”按钮，则会显示skill分类页面</p><img src="/skill/Build_a_personal_blog_based_on_Hexo/image-20210530111244240.png" class="" title="image-20210530111244240"></li><li><p>网站映射</p><p>通过上述方式创建的skill页面的网址链接中会存在中文符，为了改成英文，在根目录下的站点配置文件中修改映射值，将链接中的中文映射为英语，这样就不会乱码了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line">  <span class="string">问术:</span> <span class="string">skill</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line">  <span class="comment">#算法</span></span><br><span class="line">  <span class="string">算法:</span> <span class="string">algorithm</span></span><br><span class="line">  <span class="string">滤波:</span> <span class="string">filter</span></span><br><span class="line">  <span class="string">点云:</span> <span class="string">point</span> <span class="string">cloud</span></span><br></pre></td></tr></table></figure></li><li><p>文章模板配置</p><p>以下是post模板，其中，公式采用mathjax渲染，增加<!-- more -->来显示摘要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">urltitle: </span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">update: </span><br><span class="line"></span><br><span class="line">top: false</span><br><span class="line">toc: true</span><br><span class="line">comments: true</span><br><span class="line">mathjax: true</span><br><span class="line"></span><br><span class="line">keywords: </span><br><span class="line">description:</span><br><span class="line">tags: </span><br><span class="line">categories:</span><br><span class="line">- 111</span><br><span class="line">- 222</span><br><span class="line">- 333</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">摘要显示....</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure></li><li><p>公式</p><p>首选，安装<a href="https://github.com/jgm/pandoc/releases/tag/2.6">pandoc</a>，然后，卸载hexo默认的markd，安装<code>hexo-renderer-pandoc</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>安装hexo-math 插件以支持 latex 公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>在hexo 博客中的 _config.yml 中添加 hexo-math 插件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-emoji</span><br><span class="line">    - hexo-math</span><br></pre></td></tr></table></figure><p>打开 theme/next/_config.yml 文件，找到mathjax 位置, 设置为以下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure></li><li><p>markdown插入图片</p><p>首先，修改站点配置文件<code>_config.yml</code>中的<code>post_asset_folder: true</code></p><p>然后，使用typora编辑MarkDown文件，并在图片设置项选择“复制到指定路径”，./${filename}</p><p>最后，使用<code>hexo new “我的博客”</code>，在文章目录创建新文章，并且创建同名文件夹存放图片</p></li></ul><h1 id="日常写作">日常写作</h1><ul><li><p>新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p></li><li><p>生成静态文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></li><li><p>服务器查看更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li><p>远程部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考">参考</h1><ul><li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li><li><a href="http://theme-next.iissnan.com/">NexT 使用文档</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">使用hexo+github搭建免费个人博客详细教程</a></li><li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></li><li><a href="https://www.cnblogs.com/guide2it/articles/11111457.html">Hexo+NexT（一）：在Windows下安装Hexo+NexT及搭建博客</a></li><li><a href="https://www.cnblogs.com/wsmrzx/p/9439470.html">Hexo系列(四) NexT主题配置</a></li><li><a href="https://blog.csdn.net/as480133937/article/details/100138838/?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-4&amp;spm=1001.2101.3001.4242">Hexo-Next 主题博客个性化配置超详细</a></li><li><a href="http://www.chenlianhan.com/2020/03/20/HEXO-NEXT界面美化（持续更新）/">HEXO+NEXT界面美化</a></li><li><a href="https://blog.csdn.net/u012294515/article/details/83094693">Hexo | NexT打造一个炫酷博客</a></li><li>[<a href="https://blog.csdn.net/u012294515/article/details/83094693">Hexo+Github+jsDelivr+Vercel建站备忘录</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你要搭建个人博客网站，更注重内容的输出，而不是把时间花在网站的维护上，那么，通过Hexo来构建个人博客网站是一个很不错的选择。&lt;/p&gt;</summary>
    
    
    
    <category term="问术" scheme="https://lizhengsi.github.io/categories/skill/"/>
    
    
    <category term="hexo" scheme="https://lizhengsi.github.io/tags/hexo/"/>
    
    <category term="github" scheme="https://lizhengsi.github.io/tags/github/"/>
    
    <category term="blog" scheme="https://lizhengsi.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>关于Kalman滤波的理解</title>
    <link href="https://lizhengsi.github.io/skill/Understanding_of_Kalman_Filter/"/>
    <id>https://lizhengsi.github.io/skill/Understanding_of_Kalman_Filter/</id>
    <published>2016-08-30T07:58:52.000Z</published>
    <updated>2021-05-25T16:20:57.722Z</updated>
    
    <content type="html"><![CDATA[<p>卡尔曼滤波（Kalman filter）以它的发明者Rudolf. Emil. Kalman先生命名，是一种高效率的递归滤波器（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。在控制领域，Kalman滤波被称为<strong>线性二次型估计</strong>，其也可以认为是一个最优化自回归数据处理算法（optimal recursive data processing algorithm），广泛应用于飞机及太空船的导引、导航及控制。</p><a id="more"></a><hr /><h1 id="前言">前言</h1><p>写在本文之前，有两个重要的思想需贯穿脑海之中：  </p><blockquote><p>    1. 没有绝对准确，只有更为接近的准确<br />    2. 滤波即为加权  关于1，这个不做多说。</p></blockquote><p>关于2，对信号的滤波即是对离散序列的加权，传统的低通滤波器可以理解为高频权值为0（或接近0），而低频的权值为1，此时便可实现通低频阻高频的效果。同理，高通、带通滤波器可以理解为对不同频段的信号进行加权后获得想要的信号。 </p><h1 id="基本概念">基本概念</h1><h2 id="协方差矩阵"> 协方差矩阵</h2><p>设X、Y为随机变量，<span class="math inline">\(\mu\)</span>、<span class="math inline">\(\nu\)</span>分别为X、Y的期望。x、y分别为X、Y的真实值，<span class="math inline">\(\hat{x}\)</span>、<span class="math inline">\(\hat{y}\)</span>分别为x、y的估计值，则有：</p><ul><li><p><strong>误差</strong>：真实值与估计值的差，即<span class="math inline">\(e=x-\hat{x}\)</span></p></li><li><p><strong>方差</strong>：方差是描述随机变量与其期望值的离散程度，即<span class="math inline">\(\sigma_{X}^{2}=E(X-E(X))\)</span></p></li><li><p><strong>协方差</strong>：描述两个变量间的相关性，<span class="math inline">\(cov(X,Y)=E[(X-\mu)(Y-\nu)]\)</span> 。其中，X与Y的不相关是独立的必要不充分条件，但是对于X、Y正态分布时二者独立是不相关的充要条件。</p></li><li><p><strong>协方差矩阵</strong>：若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据；<span class="math inline">\(\mathrm{Y}\)</span>为n维向量<span class="math inline">\(\mathrm{Y}=(Y_{1},Y_{2},…,Y_{n})\)</span>，其中<span class="math inline">\(Y_{k}\)</span>中含一组数据,则<span class="math inline">\(\mathrm{X}\)</span>与<span class="math inline">\(\mathrm{Y}\)</span>的协方差应表示为mxn维协方差矩阵： <span class="math display">\[cov(\mathrm{X},\mathrm{Y})=E((\mathrm{X}-\mathrm{\mu})(\mathrm{Y}-\mathrm{\nu})^{T})=\begin{bmatrix}E[(X_{1}-\mu_{1})(Y_{1}-\nu_{1})] &amp; E[(X_{1}-\mu_{1})(Y_{2}-\nu_{2})] &amp;\cdots &amp;E[(X_{1}-\mu_{1})(Y_{n}-\nu_{n})] \\ E[(X_{2}-\mu_{2})(Y_{1}-\nu_{1})]&amp; E[(X_{2}-\mu_{2})(Y_{2}-\nu_{2})] &amp; \cdots  &amp;E[(X_{2}-\mu_{2})(Y_{n}-\nu_{n})] \\ \vdots                                         &amp; \vdots    &amp; \ddots    &amp; \vdots\\  E[(X_{m}-\mu_{m})(Y_{1}-\nu_{1})]&amp;  E[(X_{m}-\mu_{m})(Y_{2}-\nu_{2})]&amp; \cdots  &amp; E[(X_{m}-\mu_{m})(Y_{n}-\nu_{n})]\end{bmatrix}\]</span> 对于<span class="math inline">\(\mathrm{X}\)</span>自身而言，其协方差矩阵(或称为方差，详见<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%20%22wiki-协方差矩阵%22">协方差矩阵</a>)： <span class="math display">\[cov(\mathrm{X},\mathrm{X})=E((\mathrm{X}-\mathrm{\mu})(\mathrm{X}-\mathrm{\mu})^{T})=\begin{bmatrix}E[(X_{1}-\mu_{1})(X_{1}-\mu_{1})] &amp; E[(X_{1}-\mu_{1})(X_{2}-\mu_{2})] &amp;\cdots &amp;E[(X_{1}-\mu_{1})(X_{n}-\mu_{n})] \\ E[(X_{2}-\mu_{2})(X_{1}-\mu_{1})]&amp; E[(X_{2}-\mu_{2})(X_{2}-\mu_{2})] &amp; \cdots  &amp;E[(X_{2}-\mu_{2})(X_{n}-\mu_{n})] \\ \vdots                                         &amp; \vdots    &amp; \ddots    &amp; \vdots\\  E[(X_{m}-\mu_{m})(X_{1}-\mu_{1})]&amp;  E[(X_{m}-\mu_{m})(X_{2}-\mu_{2})]&amp; \cdots  &amp; E[(X_{m}-\mu_{m})(X_{n}-\mu_{n})]\end{bmatrix}\]</span> 可以从上式可以看出，矩阵对角为<span class="math inline">\(\mathrm{X}\)</span>列向量的方差。若<span class="math inline">\(\mathrm{X}\)</span>服从正态分布，其为对角矩阵。（后面可将<span class="math inline">\(\mathrm{X}\)</span>联想为状态向量，<span class="math inline">\(X_{1}\)</span>、<span class="math inline">\(X_{2}\)</span>联想为位移向量和速度向量）</p></li><li><p><strong>误差的协方差矩阵</strong>：若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据，误差为m维向量<span class="math inline">\(\mathrm{e}\)</span>，则其误差的协方差矩阵为： <span class="math display">\[P=cov(\mathrm{e},\mathrm{e})=E[\mathrm{e} \mathrm{e}^{T}]\]</span> 可知，其对角元素元素之和（或称迹）即为均方差。</p></li></ul><p> 注：此处十分重要，将状态变量的误差协方差矩阵与状态变量的最小均方差估计联系起来。</p><h2 id="最小均方误差估计">最小均方误差估计</h2><ul><li><strong>均方误差</strong>：它是"误差"的平方的，也就是多个样本的时候，均方差等于每个样本的误差平方再乘以该样本出现的概率的和，即 <span class="math display">\[MSE=E[(x-\hat{x})^{2}]=E[e^{2}]\]</span> 若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据，则<span class="math inline">\(\mathrm{X}\)</span>的均方误差：</li></ul><p><span class="math display">\[MSE=E[(\mathrm{x}-\mathrm{\hat{x}})^{T}(\mathrm{x}-\mathrm{\hat{x})}]=E[\mathrm{e}^{T}\mathrm{e}]=tr(E[\mathrm{e}\mathrm{e}^{T}])=\sum_{i=1}^{m}E[\mathrm{e}_{i}^{2}]\]</span></p><p>​ 注意，这里的<span class="math inline">\(\mathrm{e}\)</span>为m维向量，<span class="math inline">\(\mathrm{X}\)</span>的均方误差即为误差平方和的期望值，或误差平方的期望之和，这即是误差协方差矩阵的迹。</p><ul><li><strong>最小均方差（MMSE）</strong>：对于变量<span class="math inline">\(\mathrm{X}\)</span>，求其某一估计值，使均方误差最小，其最小均方误差即为：</li></ul><p><span class="math display">\[MMSE=MSE_{min}=E[(\mathrm{x}-\mathrm{\hat{x}})^{T}(\mathrm{x}-\mathrm{\hat{x})}]=E[\mathrm{e}^{T}\mathrm{e}]=tr(E[\mathrm{e}\mathrm{e}^{T}])=\sum_{i=1}^{m}E[\mathrm{e}_{i}^{2}]\]</span></p><ul><li><strong>最小均方误差估计</strong>：最小均方误差估计即最优估计，即寻找合适的估计函数<span class="math inline">\(\hat{x}=c(x)\)</span>来估计x，使上式最小。 （1）<span class="math inline">\(\mathrm{X}\)</span>为一维变量时，该估计函数为： <span class="math display">\[\hat{x}=E[X]\]</span> 其证明详见参考文献，大致过程是通过<span class="math inline">\(MSE_{min}\)</span>对<span class="math inline">\(\hat{x}\)</span>求导，令导函数为0，即可求得<span class="math inline">\(\hat{x}\)</span> 。  <br />（2）当<span class="math inline">\(\mathrm{X}\)</span>存在先验条件<span class="math inline">\(\mathrm{Y}\)</span>时，该估计函数为： <span class="math display">\[\hat{x}=E[X|Y=y]\]</span> 此时，该估计函数即为<span class="math inline">\(\mathrm{X}\)</span>在<span class="math inline">\(\mathrm{Y}\)</span>条件下的条件期望。其证明详见参考文献，证明过程同上。 （3） 当<span class="math inline">\(\mathrm{X}\)</span>存在先验条件<span class="math inline">\(\mathrm{Y}\)</span>，且<span class="math inline">\(\mathrm{X}\)</span>、<span class="math inline">\(\mathrm{Y}\)</span>为m维向量时，该估计函数为：</li></ul><p><span class="math display">\[\hat{x}(x_{1},x_{1},···,x_{m})=E[X|Y_{1}=y_{1},Y_{2}=y_{2},···,Y_{m}=y_{m}]\]</span></p><h2 id="状态描述">状态描述</h2><p>机器人的状态，是指一组完整描述它随时间运动的物理量，比如位置、角度和速度，状态估计即是在包含噪声的测量值中估计机器人的状态值，均方误差越小，估计值越接近真实值。</p><p>根据牛顿运动规律，物体的运动方程大体归结为化成如下形式： <span class="math display">\[m\frac{\mathrm{d}^{2} x}{\mathrm{d} t^{2}}+2\beta \frac{\mathrm{d} x}{\mathrm{d} t}+kx=u(t)\]</span> 化成以下形式：<br /><span class="math display">\[\ddot{x}-a_{1}\dot{x}-a_{0}x=u(t)\]</span> 再写成方程组形式：<br /><span class="math display">\[\left\{\begin{matrix}\dot{x}=0\cdot x+1\cdot\dot{x}+0\cdot u(t) &amp; &amp; \\ \ddot{x}=a_{0}x+a_{1}\dot{x}+1\cdot u(t)&amp; &amp; \end{matrix}\right.\]</span> 其矩阵形式： <span class="math display">\[\begin{pmatrix}\dot{x}\\ \ddot{x}\end{pmatrix}=  \begin{pmatrix}0 &amp; 1\\ a_{0}&amp; a_{1}\end{pmatrix}\begin{pmatrix}\ x\\ \dot{x}\end{pmatrix}  +  \begin{pmatrix}\ 0\\ \ 1\end{pmatrix}u(t)\]</span> 化简为： <span class="math display">\[\mathbf{\dot{x}}=\mathbf{Ax}+\mathbf{Bu}\]</span> 如果在方程中加入过程噪声，则有： <span class="math display">\[\ddot{x}=a_{1}\dot{x}+a_{0}x+u(t)+w(t)\]</span> 得到类似矩阵：<br /><span class="math display">\[\begin{pmatrix}\dot{x}\\ \ddot{x}\end{pmatrix}=  \begin{pmatrix}0 &amp; 1\\ a_{0}&amp; a_{1}\end{pmatrix}\begin{pmatrix}\ x\\ \dot{x}\end{pmatrix}  +\begin{pmatrix}\ 0\\ \ 1\end{pmatrix}u(t)  +\begin{pmatrix}\ 0\\ \ 1\end{pmatrix}w(t)\]</span> <strong>运动方程</strong>简化为：<br /><span class="math display">\[\mathbf{\dot{x}}=\mathbf{Ax}+\mathbf{Bu}+\mathbf{w}\]</span> <em>其中，<strong>A</strong>：传输矩阵； <strong>x</strong>：状态矢量； <strong>B</strong>：控制矩阵； <strong>u</strong>：控制矢量； <strong>w</strong>：过程噪声</em>  </p><p><strong>在这里，状态向量<span class="math inline">\(\mathbf=（x,\dot{x}）\)</span>包含位移和速度的信息。推广到多维空间，状态向量为<span class="math inline">\(\mathbf=（x_{1},x_{2},...,x_{n};\dot{x_{1}},\dot{x_{2}},...,\dot{x_{n}}）\)</span>，这种方法称为状态空间描述法。</strong></p><p>由此得到系统模型框图：</p><img src="/skill/Understanding_of_Kalman_Filter/%E8%BF%90%E5%8A%A8%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220600134"><p>除了物体运动方程，当在x状态处观测，可以得到一个观测方程： <span class="math display">\[\mathbf{z}=\mathbf{Hx}+\mathbf{v}\]</span> <em>其中，<strong>z</strong>：观测矢量； <strong>H</strong>：观测矩阵；<strong>v</strong>：观测噪声</em> 。</p><p>更新以上系统框图，则有：</p><img src="/skill/Understanding_of_Kalman_Filter/%E8%A7%82%E6%B5%8B%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220741655"><h1 id="kalman滤波器">Kalman滤波器</h1><h2 id="前提条件"> 前提条件</h2><ul><li>线性系统  </li><li>系统噪声和测量噪声服从高斯分布  </li></ul><h2 id="系统模型"> 系统模型</h2><p>卡尔曼滤波建立在线性代数和隐马尔可夫模型上，k时刻的状态在(k-1)时刻的基础上递推过来，系统模型由预测空间模型和观测空间模型组成。在上述运动方程和观测方程基础上，进行离散化并得到状态方程的形式，如下预测空间模型和观测空间模型。</p><p><strong>预测空间模型：</strong> <span class="math display">\[\mathbf{x_{k}}=\mathbf{Ax_{k-1}}+\mathbf{Bu_{k-1}}+\mathbf{w_{k-1}}\]</span> 其中：</p><ul><li><span class="math inline">\(\mathbf{x_{k}}\)</span>是k时刻的预测状态向量，<span class="math inline">\(\mathbf{x_{k-1}}\)</span>是(k-1)时刻的状态向量  </li><li><span class="math inline">\(\mathbf{u_{k-1}}\)</span>是(k-1)时刻的控制输入向量</li><li><span class="math inline">\(\mathbf{A}\)</span>是k时刻状态传输矩阵，与系统本身特性相关，其隐含指示(k-1)时刻的状态会影响到k时刻的状态  </li><li><span class="math inline">\(\mathbf{B}\)</span>是k时刻控制输入矩阵，其隐含指示(k-1)时刻的驱动输入会影响到k时刻的状态  </li><li><span class="math inline">\(\mathbf{w_{k}}\)</span>是过程噪声，服从正态分布，<span class="math inline">\(\mathbf{w_{k}}\sim N(0,Q_{k})\)</span>，<span class="math inline">\(\mathbf{Q_{k}}\)</span>为其协方差矩阵  </li></ul><p><strong>观测空间模型：</strong><br /><span class="math display">\[ \mathbf{z_{k}}=\mathbf{Hx_{k}}+\mathbf{v_{k}} \]</span> 其中：</p><ul><li><span class="math inline">\(\mathbf{z_{k}}\)</span>是k时刻的观测状态向量  </li><li><span class="math inline">\(\mathbf{H}\)</span>是k时刻的观测矩阵，把真实状态空间映射成观测空间  </li><li><span class="math inline">\(\mathbf{v_{k}}\)</span>是观测噪声，服从正态分布，<span class="math inline">\(\mathbf{v_{k}}\sim N(0,R_{k})\)</span>，<span class="math inline">\(\mathbf{R_{k}}\)</span>为其协方差矩阵  </li></ul><p>分析上述两个状态方程，不拿看出，在k时刻的预测状态向量<span class="math inline">\(\mathbf{x_{k}}\)</span>（或观测状态向量<span class="math inline">\(\mathbf{z_{k}}\)</span>）是在第(k-1)时刻的状态上推导而来（马尔科夫模型），并且都在状态更新的过程中带入新的高斯噪声。离散框图如下：</p><img src="/skill/Understanding_of_Kalman_Filter/%E7%A6%BB%E6%95%A3%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220852476"><p>那么问题来了，既然既可以通过预测，亦可以通过观测，来获知系统在k时刻的状态，但是二者都存在误差（噪声），那么二者哪个更可靠呢？这时，我们自然而然的想到了的加权的思想，通过对二者的加权获得k时刻的准确的状态。  通过以下图片可以帮我们更好地理解，小车距出发地的距离可以通过预测模型和测量模型获得，且二者都服从正态分布，都存在误差。通过对二者加权，得到我们想要的较为准确的状态模型（图中绿色表示），但是，这个模型也存在误差，服从正态分布。</p><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A601.jpg" class="" title="示例小车01"><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A602.jpg" class="" title="示例小车02"><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A603.jpg" class="" title="示例小车03"><img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A604.jpg" class="" title="示例小车04"><p><strong>综上，kalman滤波可以看做是对预测模型和观测模型进行加权处理，获取更加接近实际值新的状态估计值。实际上，kalman滤波即是利用观测模型的残差来修正预测模型（最优估计），同时计算残差的权值。</strong>  </p><h2 id="递推方程"> 递推方程</h2><p>kalman滤波器用于估计离散时间过程的状态变量<span class="math inline">\(x\in\Re^{n}\)</span>，这个离散时间过程由以下离散随机差分方程描述：</p><p>设<span class="math inline">\(\mathbf{x}_{k}^{-}\in\Re^{n}\)</span>(-代表先验，^代表估计)为在已知第 k步以前状态情况下第 k 步的先验状态估计。<span class="math inline">\(\mathbf{\hat{x}}_{k}\in\Re^{n}\)</span>为已知测量变量<span class="math inline">\(\mathbf{z}_{k}\)</span>时第k步的后验状态估计。由此定义先验估计误差和后验估计误差： <span class="math display">\[\mathbf{e_{k}^{-}}=\mathbf{x_{k}} - \mathbf{\hat{x}_{k}^{-}}  ,  \mathbf{e_{k}}=\mathbf{x_{k}}  -  \mathbf{\hat{x}_{k}}\]</span> 先验估计误差的协方差为： <span class="math display">\[\mathbf{P_{k}^{-}} = E[\mathbf{e_{k}^{-}}  \mathbf{(e_{k}^{-})^{T}}]\]</span> 后验估计误差的协方差为： <span class="math display">\[\mathbf{P_{k}} = E[\mathbf{e_{k}}  \mathbf{(e_{k})^{T}}]\]</span> 那么，对于预测和测量状态空间方程，即为：</p><p><strong>预测空间模型-预测值（先验估计）：</strong> <span class="math display">\[\mathbf{\hat{x}_{k}^{-}}=\mathbf{A\hat{x}_{k-1}}+\mathbf{B{u}_{k-1}}\]</span> <strong>观测空间模型-测量值（测量值的预测）：</strong><br /><span class="math display">\[\mathbf{\hat{z}_{k}}=\mathbf{H\hat{x}_{k}^{-}}\]</span></p><blockquote><p>  实际测量值：$ = +  =  + $</p></blockquote><p>这时，要在测量值的基础上再次更新状态变量<span class="math inline">\(x\)</span>的先验估计，可得到后验估计，得到最优估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>： <span class="math display">\[\mathbf{\hat{x}_{k}} = \mathbf{\hat{x}_{k}^{-}} + \mathbf{K_{k}} (\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})\]</span> 上式构造了kalman滤波器的表达式，先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>和加权的预测残差<span class="math inline">\((\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})\)</span>线性的构成了后验状态估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>。</p><h2 id="递推方程的解释">递推方程的解释</h2><p>（1） <span class="math inline">\(\mathbf{x_{k}}\)</span> 的概率原型。这个可以见参考文献，来源于贝叶斯规则：<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的更新取决于在已知先前的测量变量<span class="math inline">\(\mathbf{z_{k}}\)</span>的情况下<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>的概率分布。在已知 <span class="math inline">\(\mathbf{z_{k}}\)</span>的情况下，<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的分布可写为： <span class="math display">\[p(\mathbf{x_{k}} | \mathbf{z_{k}}) - N(\mathbf{\hat{x}_{k}},\mathbf{P_{k}})\]</span> 即为正态分布。</p><p>（2） <span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的推导。关于<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的形式，利用最优估计的原理，可以用极大似然估计可以推导，在论文中还看到过一种是将预测和测量的正态分布相乘求联合正态分布，联合正态分布即为后验状态估计。这里应该可以用反馈的原理来解释（如下面这张图），以测量值作为反馈，来进一步修正状态变量<span class="math inline">\(x\)</span>的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>，得到后验估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>。</p><img src="/skill/Understanding_of_Kalman_Filter/%E5%8F%8D%E9%A6%88%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525222308034"><p>（3） <span class="math inline">\(\mathbf{K_{k}}\)</span>的推导。既然<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>是<span class="math inline">\(\mathbf{x_{k}}\)</span>的最优估计，那么<span class="math inline">\(\mathbf{x_{k}}\)</span>的误差协方差矩阵的迹<span class="math inline">\(tr[\mathbf{P_{k}}]\)</span>(<span class="math inline">\(\mathbf{P_{k}}\)</span>的计算见下面)最小，即<span class="math inline">\(\mathbf{x_{k}}\)</span>的均方误差最小。此时，将后验估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的表达式和误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>的表达式联立，即可求得<span class="math inline">\(tr[\mathbf{P_{k}}]\)</span>，对其求导，导函数为零时求得<span class="math inline">\(\mathbf{K_{k}}\)</span>： <span class="math display">\[\mathbf{K_{k}} = \mathbf{P_{k}^{-}}\mathbf{H^{T}}(\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R})^{-1}= \frac{\mathbf{P_{k}^{-}}\mathbf{H^{T}}}{\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R}}\]</span></p><h2 id="离散kalman滤波算法"> 离散Kalman滤波算法</h2><p>卡尔曼滤波器用反馈控制的方法估计过程状态：滤波器估计某一时刻的过程状态，然后以测量变量（含噪声）的方式获得反馈。</p><p>因此卡尔曼滤波器可分为两个部分：时间更新方程和测量更新方程。时间更新方程负责及时向前推算当前状态变量和误差协方差估计的值，以便为下一个时间状态构造先验估计。测量更新方程负责反馈，它将先验估计和新的测量变量结合以构造改进的后验估计。时间更新方程也可视为预估方程，测量更新方程可视为校正方程。最后的估计算法成为一种具有数值解的预估－校正算法。</p><img src="/skill/Understanding_of_Kalman_Filter/%E9%A2%84%E6%B5%8B%E6%A0%A1%E6%AD%A3.png" class="" title="image-20210525224607696"><p><strong>离散卡尔曼滤波时间更新方程</strong> <span class="math display">\[\left\{\begin{matrix}\mathbf{\hat{x}_{k}^{-}}=\mathbf{A\hat{x}_{k-1}}+\mathbf{Bu_{k-1}}\\ \mathbf{P_{k}^{-}}=\mathbf{A} \boldsymbol{P_{k-1}} \mathbf{A^{T}} + \mathbf{Q}\end{matrix}\right.\]</span> 时间更新方程主要获取由预测方程预测的k时刻的状态<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>，为<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的先验状态估计；此时，其误差的协方差矩阵为<span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>。</p><blockquote><p>  上式中，存在未知参数<span class="math inline">\(\mathbf{A}\)</span>, <span class="math inline">\(\mathbf{B}\)</span>, <span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>, <span class="math inline">\(\mathbf{P_{k-1}}\)</span>, <span class="math inline">\(\mathbf{Q}\)</span>  (1) 关于<span class="math inline">\(\mathbf{A}\)</span>。这是和状态向量相关的矩阵，具体见举例  (2) 关于<span class="math inline">\(\mathbf{B}\)</span>。这是驱动矩阵，和外部输入驱动有关，具体见举例  (3) 关于 <span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>。这是k时刻的先验状态估计的误差协方差矩阵，与预测方程的噪声有关，是根据（k-1）时刻的误差协方差矩阵<span class="math inline">\(\mathbf{P_{k-1}}\)</span>递推而来（<span class="math inline">\(\mathbf{P_{k-1}}\)</span>一般是给定的初值），利用<span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>的表达式 <span class="math inline">\(\mathbf{P_{k}^{-}} = E[\mathbf{e_{k}^{-}}  \mathbf{(e_{k}^{-})^{T}}]\)</span>即可求得。  (4) 关于<span class="math inline">\(\mathbf{P_{k-1}}\)</span>。（k-1）时刻的误差协方差矩阵（<span class="math inline">\(\mathbf{P_{k-1}}\)</span>一般是给定的初值）  (5) 关于<span class="math inline">\(\mathbf{Q}\)</span>。过程噪声（预测误差）<span class="math inline">\(\mathbf{w_{k-1}}\)</span>的协方差矩阵，在预测的过程中产生。</p></blockquote><p><strong>离散卡尔曼滤波状态更新方程</strong> <span class="math display">\[\left\{\begin{matrix}\mathbf{K_{k}} = \mathbf{P_{k}^{-}}\mathbf{H^{T}}(\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R})^{-1}\\\mathbf{\hat{x}_{k}} = \mathbf{\hat{x}_{k}^{-}} + \mathbf{K_{k}} (\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})\\ \mathbf{P_{k}}=(\mathbf{I} - \mathbf{K_{k}}\mathbf{H} )\mathbf{P_{k}^{-}}\end{matrix}\right.\]</span> 状态更新方程在预测的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>上，同测量值<span class="math inline">\(\mathbf{z_{k}}\)</span>进行融合，更新校正先验状态估计，得到k时刻的后验状态估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>；此时，递推出后验状态估计的误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>，由此可以得到MMSE的条件，求得<span class="math inline">\(\mathbf{K_{k}}\)</span></p><blockquote><p>  上式中，存在未知参数<span class="math inline">\(\mathbf{K_{k}}\)</span>, <span class="math inline">\(\mathbf{H}\)</span>, <span class="math inline">\(\mathbf{R}\)</span>, <span class="math inline">\(\mathbf{z_{k}}\)</span>, <span class="math inline">\(\mathbf{P_{k}}\)</span>  (1) 关于<span class="math inline">\(\mathbf{K_{k}}\)</span>。残差（真实测量值与基于先验状态估计的测量值（估计量））的增益，可以看做测量反馈的增益  (2) 关于<span class="math inline">\(\mathbf{H}\)</span>。这是观测矩阵，和状态向量有关，具体见举例  (3) 关于<span class="math inline">\(\mathbf{R}\)</span>。测量噪声（测量误差）<span class="math inline">\(\mathbf{v_{k-1}}\)</span>的协方差矩阵，在测量的过程中产生。   (4) 关于<span class="math inline">\(\mathbf{z_{k}}\)</span>。k时刻的真是测量值。  (5) 关于<span class="math inline">\(\mathbf{P_{k}}\)</span>。k时刻的后验估计的误差协方差矩阵。</p></blockquote><p>因此，通过时间更新和测量更新的不断递推，便可得到比较准确的状态向量估计值。其中，若初始过程噪声<span class="math inline">\(w_{k}\)</span>和测量噪声<span class="math inline">\(v_{k}\)</span>为一确定值，不断递推后状态向量误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>和卡尔曼增益<span class="math inline">\(\mathbf{K_{k}}\)</span>会收敛并保持常量。下图显示了滤波器整个操作流程。</p><img src="/skill/Understanding_of_Kalman_Filter/%E6%BB%A4%E6%B3%A2%E5%99%A8%E6%B5%81%E7%A8%8B.png" class="" title="image-20210525224729900"><hr /><h1 id="程序">程序</h1><h2 id="matlab程序"> Matlab程序</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% kalman filter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% x(k+1) = Fk * x(k) + Wk; 预测模型</span></span><br><span class="line"><span class="comment">% y(k)   = Hk * x(k) + Vk; 观测模型</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">365</span>;</span><br><span class="line"></span><br><span class="line">Fk = [<span class="number">1</span>];               <span class="comment">% 状态转移矩阵               </span></span><br><span class="line">X  = <span class="built_in">zeros</span>(N,<span class="number">1</span>);        <span class="comment">% 初始化状态变量</span></span><br><span class="line">W  = <span class="number">12</span>*<span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 构造过程噪声</span></span><br><span class="line">X(<span class="number">1</span>) = <span class="number">100</span>;             <span class="comment">% 初始状态</span></span><br><span class="line">                    </span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 状态方程</span></span><br><span class="line">    X(k) = Fk * X(k<span class="number">-1</span>) + W(k<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Hk = [<span class="number">2</span>];               <span class="comment">% 观测矩阵                </span></span><br><span class="line">Y  = <span class="built_in">zeros</span>(N,<span class="number">1</span>);        <span class="comment">% 初始化观测变量</span></span><br><span class="line">V  = <span class="number">20</span>*<span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 构造观测噪声</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:N</span><br><span class="line">    <span class="comment">% 观测方程</span></span><br><span class="line">    Y(k) = Hk * X(k) + V(k);   </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Q  = cov(W);            <span class="comment">% 过程噪声协方差；    </span></span><br><span class="line">R  = cov(V);            <span class="comment">% 观测噪声协方差；          </span></span><br><span class="line"></span><br><span class="line">Xupdate = <span class="built_in">zeros</span>(N,<span class="number">1</span>);   </span><br><span class="line">Xupdate(<span class="number">1</span>) = Y(<span class="number">1</span>);      <span class="comment">% 初始化第一个，也就是观测到的第一个 </span></span><br><span class="line">Pupdate(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 五大核心方程</span></span><br><span class="line">    Xpredict(k) = Fk * Xupdate(k<span class="number">-1</span>);</span><br><span class="line">    Ppredict(k) = Fk * Pupdate(k<span class="number">-1</span>) * Fk&#x27; + Q;</span><br><span class="line">    K = Ppredict(k) * Hk * (Hk * Ppredict(k) * Hk&#x27; + R).^<span class="number">-1</span>;</span><br><span class="line">    Xupdate(k) = (<span class="number">1</span> - K * Hk) * Xpredict(k) + K * Y(k);</span><br><span class="line">    Pupdate(k) = (<span class="number">1</span> - K * Hk) * Ppredict(k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,X,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,Y,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,Xupdate,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,<span class="built_in">abs</span>(Xupdate-X),<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;真值&#x27;</span>,<span class="string">&#x27;观测值&#x27;</span>,<span class="string">&#x27;滤波值&#x27;</span>,<span class="string">&#x27;误差&#x27;</span>)</span><br></pre></td></tr></table></figure><hr /><h1 id="参考">参考</h1><ul><li>https://www.zhihu.com/question/23971601  </li><li>http://blog.csdn.net/xiahouzuoxin/article/details/39582483  </li><li>https://zhuanlan.zhihu.com/p/21889676  </li><li>https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2  </li><li>https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95</li><li>http://www.jianshu.com/p/2768642e3abf</li><li>http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/</li><li>Ramsey Faragher. Understanding the Basis of the Kalman Filter. 2012</li><li>Greg Welch, Gary Bishop. An Introduction to the Kalman Filter. 2001</li><li>Don Johnson. Minimum Mean Squared Error Estimators. 2004</li><li>R.E.Kalman. A new approach to linear filtering and prediction problems. 1960</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;卡尔曼滤波（Kalman filter）以它的发明者Rudolf. Emil. Kalman先生命名，是一种高效率的递归滤波器（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。在控制领域，Kalman滤波被称为&lt;strong&gt;线性二次型估计&lt;/strong&gt;，其也可以认为是一个最优化自回归数据处理算法（optimal recursive data processing algorithm），广泛应用于飞机及太空船的导引、导航及控制。&lt;/p&gt;</summary>
    
    
    
    <category term="问术" scheme="https://lizhengsi.github.io/categories/skill/"/>
    
    
    <category term="Kalman filter" scheme="https://lizhengsi.github.io/tags/Kalman-filter/"/>
    
  </entry>
  
</feed>
