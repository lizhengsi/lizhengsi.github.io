<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于Hexo搭建个人博客</title>
    <url>/skill/Build%20a%20personal%20blog%20based%20on%20Hexo/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
      <categories>
        <category>问术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Kalman滤波的理解</title>
    <url>/skill/Understanding_of_Kalman_Filter/</url>
    <content><![CDATA[<p>卡尔曼滤波（Kalman filter）以它的发明者Rudolf. Emil. Kalman先生命名，是一种高效率的递归滤波器（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。在控制领域，Kalman滤波被称为<strong>线性二次型估计</strong>，其也可以认为是一个最优化自回归数据处理算法（optimal recursive data processing algorithm），广泛应用于飞机及太空船的导引、导航及控制。</p>
<a id="more"></a>
<hr />
<h1 id="前言">前言</h1>
<p>写在本文之前，有两个重要的思想需贯穿脑海之中：  </p>
<blockquote>
<p>    1. 没有绝对准确，只有更为接近的准确<br />
    2. 滤波即为加权  关于1，这个不做多说。</p>
</blockquote>
<p>关于2，对信号的滤波即是对离散序列的加权，传统的低通滤波器可以理解为高频权值为0（或接近0），而低频的权值为1，此时便可实现通低频阻高频的效果。同理，高通、带通滤波器可以理解为对不同频段的信号进行加权后获得想要的信号。 </p>
<h1 id="基本概念">基本概念</h1>
<h2 id="协方差矩阵"> 协方差矩阵</h2>
<p>设X、Y为随机变量，<span class="math inline">\(\mu\)</span>、<span class="math inline">\(\nu\)</span>分别为X、Y的期望。x、y分别为X、Y的真实值，<span class="math inline">\(\hat{x}\)</span>、<span class="math inline">\(\hat{y}\)</span>分别为x、y的估计值，则有：</p>
<ul>
<li><p><strong>误差</strong>：真实值与估计值的差，即<span class="math inline">\(e=x-\hat{x}\)</span></p></li>
<li><p><strong>方差</strong>：方差是描述随机变量与其期望值的离散程度，即<span class="math inline">\(\sigma_{X}^{2}=E(X-E(X))\)</span></p></li>
<li><p><strong>协方差</strong>：描述两个变量间的相关性，<span class="math inline">\(cov(X,Y)=E[(X-\mu)(Y-\nu)]\)</span> 。其中，X与Y的不相关是独立的必要不充分条件，但是对于X、Y正态分布时二者独立是不相关的充要条件。</p></li>
<li><p><strong>协方差矩阵</strong>：若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据；<span class="math inline">\(\mathrm{Y}\)</span>为n维向量<span class="math inline">\(\mathrm{Y}=(Y_{1},Y_{2},…,Y_{n})\)</span>，其中<span class="math inline">\(Y_{k}\)</span>中含一组数据,则<span class="math inline">\(\mathrm{X}\)</span>与<span class="math inline">\(\mathrm{Y}\)</span>的协方差应表示为mxn维协方差矩阵： <span class="math display">\[
cov(\mathrm{X},\mathrm{Y})=E((\mathrm{X}-\mathrm{\mu})(\mathrm{Y}-\mathrm{\nu})^{T})=
\begin{bmatrix}
E[(X_{1}-\mu_{1})(Y_{1}-\nu_{1})] &amp; E[(X_{1}-\mu_{1})(Y_{2}-\nu_{2})] &amp;\cdots &amp;E[(X_{1}-\mu_{1})(Y_{n}-\nu_{n})] \\ 
E[(X_{2}-\mu_{2})(Y_{1}-\nu_{1})]&amp; E[(X_{2}-\mu_{2})(Y_{2}-\nu_{2})] &amp; \cdots  &amp;E[(X_{2}-\mu_{2})(Y_{n}-\nu_{n})] \\ 
\vdots                                         &amp; \vdots    &amp; \ddots    &amp; \vdots\\  
E[(X_{m}-\mu_{m})(Y_{1}-\nu_{1})]&amp;  E[(X_{m}-\mu_{m})(Y_{2}-\nu_{2})]&amp; \cdots  &amp; E[(X_{m}-\mu_{m})(Y_{n}-\nu_{n})]
\end{bmatrix}
\]</span> 对于<span class="math inline">\(\mathrm{X}\)</span>自身而言，其协方差矩阵(或称为方差，详见<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%20%22wiki-协方差矩阵%22">协方差矩阵</a>)： <span class="math display">\[
cov(\mathrm{X},\mathrm{X})=E((\mathrm{X}-\mathrm{\mu})(\mathrm{X}-\mathrm{\mu})^{T})=
\begin{bmatrix}
E[(X_{1}-\mu_{1})(X_{1}-\mu_{1})] &amp; E[(X_{1}-\mu_{1})(X_{2}-\mu_{2})] &amp;\cdots &amp;E[(X_{1}-\mu_{1})(X_{n}-\mu_{n})] \\ 
E[(X_{2}-\mu_{2})(X_{1}-\mu_{1})]&amp; E[(X_{2}-\mu_{2})(X_{2}-\mu_{2})] &amp; \cdots  &amp;E[(X_{2}-\mu_{2})(X_{n}-\mu_{n})] \\ 
\vdots                                         &amp; \vdots    &amp; \ddots    &amp; \vdots\\  
E[(X_{m}-\mu_{m})(X_{1}-\mu_{1})]&amp;  E[(X_{m}-\mu_{m})(X_{2}-\mu_{2})]&amp; \cdots  &amp; E[(X_{m}-\mu_{m})(X_{n}-\mu_{n})]
\end{bmatrix}
\]</span> 可以从上式可以看出，矩阵对角为<span class="math inline">\(\mathrm{X}\)</span>列向量的方差。若<span class="math inline">\(\mathrm{X}\)</span>服从正态分布，其为对角矩阵。（后面可将<span class="math inline">\(\mathrm{X}\)</span>联想为状态向量，<span class="math inline">\(X_{1}\)</span>、<span class="math inline">\(X_{2}\)</span>联想为位移向量和速度向量）</p></li>
<li><p><strong>误差的协方差矩阵</strong>：若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据，误差为m维向量<span class="math inline">\(\mathrm{e}\)</span>，则其误差的协方差矩阵为： <span class="math display">\[
P=cov(\mathrm{e},\mathrm{e})=E[\mathrm{e} \mathrm{e}^{T}]
\]</span> 可知，其对角元素元素之和（或称迹）即为均方差。</p></li>
</ul>
<p> 注：此处十分重要，将状态变量的误差协方差矩阵与状态变量的最小均方差估计联系起来。</p>
<h2 id="最小均方误差估计">最小均方误差估计</h2>
<ul>
<li><strong>均方误差</strong>：它是"误差"的平方的，也就是多个样本的时候，均方差等于每个样本的误差平方再乘以该样本出现的概率的和，即 <span class="math display">\[
MSE=E[(x-\hat{x})^{2}]=E[e^{2}]
\]</span> 若<span class="math inline">\(\mathrm{X}\)</span>为m维向量<span class="math inline">\(\mathrm{X}=(X_{1},X_{2},…,X_{m})\)</span>，其中<span class="math inline">\(X_{k}\)</span>中含一组数据，则<span class="math inline">\(\mathrm{X}\)</span>的均方误差：</li>
</ul>
<p><span class="math display">\[
MSE=E[(\mathrm{x}-\mathrm{\hat{x}})^{T}(\mathrm{x}-\mathrm{\hat{x})}]=E[\mathrm{e}^{T}\mathrm{e}]=tr(E[\mathrm{e}\mathrm{e}^{T}])=\sum_{i=1}^{m}E[\mathrm{e}_{i}^{2}]
\]</span></p>
<p>​ 注意，这里的<span class="math inline">\(\mathrm{e}\)</span>为m维向量，<span class="math inline">\(\mathrm{X}\)</span>的均方误差即为误差平方和的期望值，或误差平方的期望之和，这即是误差协方差矩阵的迹。</p>
<ul>
<li><strong>最小均方差（MMSE）</strong>：对于变量<span class="math inline">\(\mathrm{X}\)</span>，求其某一估计值，使均方误差最小，其最小均方误差即为：</li>
</ul>
<p><span class="math display">\[
MMSE=MSE_{min}=E[(\mathrm{x}-\mathrm{\hat{x}})^{T}(\mathrm{x}-\mathrm{\hat{x})}]=E[\mathrm{e}^{T}\mathrm{e}]=tr(E[\mathrm{e}\mathrm{e}^{T}])=\sum_{i=1}^{m}E[\mathrm{e}_{i}^{2}]
\]</span></p>
<ul>
<li><strong>最小均方误差估计</strong>：最小均方误差估计即最优估计，即寻找合适的估计函数<span class="math inline">\(\hat{x}=c(x)\)</span>来估计x，使上式最小。 （1）<span class="math inline">\(\mathrm{X}\)</span>为一维变量时，该估计函数为： <span class="math display">\[
\hat{x}=E[X]
\]</span> 其证明详见参考文献，大致过程是通过<span class="math inline">\(MSE_{min}\)</span>对<span class="math inline">\(\hat{x}\)</span>求导，令导函数为0，即可求得<span class="math inline">\(\hat{x}\)</span> 。  <br />
（2）当<span class="math inline">\(\mathrm{X}\)</span>存在先验条件<span class="math inline">\(\mathrm{Y}\)</span>时，该估计函数为： <span class="math display">\[
\hat{x}=E[X|Y=y]
\]</span> 此时，该估计函数即为<span class="math inline">\(\mathrm{X}\)</span>在<span class="math inline">\(\mathrm{Y}\)</span>条件下的条件期望。其证明详见参考文献，证明过程同上。 （3） 当<span class="math inline">\(\mathrm{X}\)</span>存在先验条件<span class="math inline">\(\mathrm{Y}\)</span>，且<span class="math inline">\(\mathrm{X}\)</span>、<span class="math inline">\(\mathrm{Y}\)</span>为m维向量时，该估计函数为：</li>
</ul>
<p><span class="math display">\[
\hat{x}(x_{1},x_{1},···,x_{m})=E[X|Y_{1}=y_{1},Y_{2}=y_{2},···,Y_{m}=y_{m}]
\]</span></p>
<h2 id="状态描述">状态描述</h2>
<p>机器人的状态，是指一组完整描述它随时间运动的物理量，比如位置、角度和速度，状态估计即是在包含噪声的测量值中估计机器人的状态值，均方误差越小，估计值越接近真实值。</p>
<p>根据牛顿运动规律，物体的运动方程大体归结为化成如下形式： <span class="math display">\[
m\frac{\mathrm{d}^{2} x}{\mathrm{d} t^{2}}+2\beta \frac{\mathrm{d} x}{\mathrm{d} t}+kx=u(t)
\]</span> 化成以下形式：<br />
<span class="math display">\[
\ddot{x}-a_{1}\dot{x}-a_{0}x=u(t)
\]</span> 再写成方程组形式：<br />
<span class="math display">\[
\left\{\begin{matrix}\dot{x}=0\cdot x+1\cdot\dot{x}+0\cdot u(t) &amp; &amp; \\ \ddot{x}=a_{0}x+a_{1}\dot{x}+1\cdot u(t)&amp; &amp; \end{matrix}\right.
\]</span> 其矩阵形式： <span class="math display">\[
\begin{pmatrix}\dot{x}\\ \ddot{x}\end{pmatrix}=  \begin{pmatrix}0 &amp; 1\\ a_{0}&amp; a_{1}\end{pmatrix}\begin{pmatrix}\ x\\ \dot{x}\end{pmatrix}  +  \begin{pmatrix}\ 0\\ \ 1\end{pmatrix}u(t)
\]</span> 化简为： <span class="math display">\[
\mathbf{\dot{x}}=\mathbf{Ax}+\mathbf{Bu}
\]</span> 如果在方程中加入过程噪声，则有： <span class="math display">\[
\ddot{x}=a_{1}\dot{x}+a_{0}x+u(t)+w(t)
\]</span> 得到类似矩阵：<br />
<span class="math display">\[
\begin{pmatrix}\dot{x}\\ \ddot{x}\end{pmatrix}=  \begin{pmatrix}0 &amp; 1\\ a_{0}&amp; a_{1}\end{pmatrix}\begin{pmatrix}\ x\\ \dot{x}\end{pmatrix}  +\begin{pmatrix}\ 0\\ \ 1\end{pmatrix}u(t)  +\begin{pmatrix}\ 0\\ \ 1\end{pmatrix}w(t)
\]</span> <strong>运动方程</strong>简化为：<br />
<span class="math display">\[
\mathbf{\dot{x}}=\mathbf{Ax}+\mathbf{Bu}+\mathbf{w}
\]</span> <em>其中，<strong>A</strong>：传输矩阵； <strong>x</strong>：状态矢量； <strong>B</strong>：控制矩阵； <strong>u</strong>：控制矢量； <strong>w</strong>：过程噪声</em>  </p>
<p><strong>在这里，状态向量<span class="math inline">\(\mathbf=（x,\dot{x}）\)</span>包含位移和速度的信息。推广到多维空间，状态向量为<span class="math inline">\(\mathbf=（x_{1},x_{2},...,x_{n};\dot{x_{1}},\dot{x_{2}},...,\dot{x_{n}}）\)</span>，这种方法称为状态空间描述法。</strong></p>
<p>由此得到系统模型框图：</p>
<img src="/skill/Understanding_of_Kalman_Filter/%E8%BF%90%E5%8A%A8%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220600134">
<p>除了物体运动方程，当在x状态处观测，可以得到一个观测方程： <span class="math display">\[
\mathbf{z}=\mathbf{Hx}+\mathbf{v}
\]</span> <em>其中，<strong>z</strong>：观测矢量； <strong>H</strong>：观测矩阵；<strong>v</strong>：观测噪声</em> 。</p>
<p>更新以上系统框图，则有：</p>
<img src="/skill/Understanding_of_Kalman_Filter/%E8%A7%82%E6%B5%8B%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220741655">
<h1 id="kalman滤波器">Kalman滤波器</h1>
<h2 id="前提条件"> 前提条件</h2>
<ul>
<li>线性系统  </li>
<li>系统噪声和测量噪声服从高斯分布  </li>
</ul>
<h2 id="系统模型"> 系统模型</h2>
<p>卡尔曼滤波建立在线性代数和隐马尔可夫模型上，k时刻的状态在(k-1)时刻的基础上递推过来，系统模型由预测空间模型和观测空间模型组成。在上述运动方程和观测方程基础上，进行离散化并得到状态方程的形式，如下预测空间模型和观测空间模型。</p>
<p><strong>预测空间模型：</strong> <span class="math display">\[
\mathbf{x_{k}}=\mathbf{Ax_{k-1}}+\mathbf{Bu_{k-1}}+\mathbf{w_{k-1}}
\]</span> 其中：</p>
<ul>
<li><span class="math inline">\(\mathbf{x_{k}}\)</span>是k时刻的预测状态向量，<span class="math inline">\(\mathbf{x_{k-1}}\)</span>是(k-1)时刻的状态向量  </li>
<li><span class="math inline">\(\mathbf{u_{k-1}}\)</span>是(k-1)时刻的控制输入向量</li>
<li><span class="math inline">\(\mathbf{A}\)</span>是k时刻状态传输矩阵，与系统本身特性相关，其隐含指示(k-1)时刻的状态会影响到k时刻的状态  </li>
<li><span class="math inline">\(\mathbf{B}\)</span>是k时刻控制输入矩阵，其隐含指示(k-1)时刻的驱动输入会影响到k时刻的状态  </li>
<li><span class="math inline">\(\mathbf{w_{k}}\)</span>是过程噪声，服从正态分布，<span class="math inline">\(\mathbf{w_{k}}\sim N(0,Q_{k})\)</span>，<span class="math inline">\(\mathbf{Q_{k}}\)</span>为其协方差矩阵  </li>
</ul>
<p><strong>观测空间模型：</strong><br />
<span class="math display">\[
 \mathbf{z_{k}}=\mathbf{Hx_{k}}+\mathbf{v_{k}} 
\]</span> 其中：</p>
<ul>
<li><span class="math inline">\(\mathbf{z_{k}}\)</span>是k时刻的观测状态向量  </li>
<li><span class="math inline">\(\mathbf{H}\)</span>是k时刻的观测矩阵，把真实状态空间映射成观测空间  </li>
<li><span class="math inline">\(\mathbf{v_{k}}\)</span>是观测噪声，服从正态分布，<span class="math inline">\(\mathbf{v_{k}}\sim N(0,R_{k})\)</span>，<span class="math inline">\(\mathbf{R_{k}}\)</span>为其协方差矩阵  </li>
</ul>
<p>分析上述两个状态方程，不拿看出，在k时刻的预测状态向量<span class="math inline">\(\mathbf{x_{k}}\)</span>（或观测状态向量<span class="math inline">\(\mathbf{z_{k}}\)</span>）是在第(k-1)时刻的状态上推导而来（马尔科夫模型），并且都在状态更新的过程中带入新的高斯噪声。离散框图如下：</p>
<img src="/skill/Understanding_of_Kalman_Filter/%E7%A6%BB%E6%95%A3%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525220852476">
<p>那么问题来了，既然既可以通过预测，亦可以通过观测，来获知系统在k时刻的状态，但是二者都存在误差（噪声），那么二者哪个更可靠呢？这时，我们自然而然的想到了的加权的思想，通过对二者的加权获得k时刻的准确的状态。  通过以下图片可以帮我们更好地理解，小车距出发地的距离可以通过预测模型和测量模型获得，且二者都服从正态分布，都存在误差。通过对二者加权，得到我们想要的较为准确的状态模型（图中绿色表示），但是，这个模型也存在误差，服从正态分布。</p>
<img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A601.jpg" class="" title="示例小车01">
<img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A602.jpg" class="" title="示例小车02">
<img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A603.jpg" class="" title="示例小车03">
<img src="/skill/Understanding_of_Kalman_Filter/%E7%A4%BA%E4%BE%8B%E5%B0%8F%E8%BD%A604.jpg" class="" title="示例小车04">
<p><strong>综上，kalman滤波可以看做是对预测模型和观测模型进行加权处理，获取更加接近实际值新的状态估计值。实际上，kalman滤波即是利用观测模型的残差来修正预测模型（最优估计），同时计算残差的权值。</strong>  </p>
<h2 id="递推方程"> 递推方程</h2>
<p>kalman滤波器用于估计离散时间过程的状态变量<span class="math inline">\(x\in\Re^{n}\)</span>，这个离散时间过程由以下离散随机差分方程描述：</p>
<p>设<span class="math inline">\(\mathbf{x}_{k}^{-}\in\Re^{n}\)</span>(-代表先验，^代表估计)为在已知第 k步以前状态情况下第 k 步的先验状态估计。<span class="math inline">\(\mathbf{\hat{x}}_{k}\in\Re^{n}\)</span>为已知测量变量<span class="math inline">\(\mathbf{z}_{k}\)</span>时第k步的后验状态估计。由此定义先验估计误差和后验估计误差： <span class="math display">\[
\mathbf{e_{k}^{-}}=\mathbf{x_{k}} - \mathbf{\hat{x}_{k}^{-}}  ,  \mathbf{e_{k}}=\mathbf{x_{k}}  -  \mathbf{\hat{x}_{k}}
\]</span> 先验估计误差的协方差为： <span class="math display">\[
\mathbf{P_{k}^{-}} = E[\mathbf{e_{k}^{-}}  \mathbf{(e_{k}^{-})^{T}}]
\]</span> 后验估计误差的协方差为： <span class="math display">\[
\mathbf{P_{k}} = E[\mathbf{e_{k}}  \mathbf{(e_{k})^{T}}]
\]</span> 那么，对于预测和测量状态空间方程，即为：</p>
<p><strong>预测空间模型-预测值（先验估计）：</strong> <span class="math display">\[
\mathbf{\hat{x}_{k}^{-}}=\mathbf{A\hat{x}_{k-1}}+\mathbf{B{u}_{k-1}}
\]</span> <strong>观测空间模型-测量值（测量值的预测）：</strong><br />
<span class="math display">\[
\mathbf{\hat{z}_{k}}=\mathbf{H\hat{x}_{k}^{-}}
\]</span></p>
<blockquote>
<p>  实际测量值：$ = +  =  + $</p>
</blockquote>
<p>这时，要在测量值的基础上再次更新状态变量<span class="math inline">\(x\)</span>的先验估计，可得到后验估计，得到最优估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>： <span class="math display">\[
\mathbf{\hat{x}_{k}} = \mathbf{\hat{x}_{k}^{-}} + \mathbf{K_{k}} (\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})
\]</span> 上式构造了kalman滤波器的表达式，先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>和加权的预测残差<span class="math inline">\((\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})\)</span>线性的构成了后验状态估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>。</p>
<h2 id="递推方程的解释">递推方程的解释</h2>
<p>（1） <span class="math inline">\(\mathbf{x_{k}}\)</span> 的概率原型。这个可以见参考文献，来源于贝叶斯规则：<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的更新取决于在已知先前的测量变量<span class="math inline">\(\mathbf{z_{k}}\)</span>的情况下<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>的概率分布。在已知 <span class="math inline">\(\mathbf{z_{k}}\)</span>的情况下，<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的分布可写为： <span class="math display">\[
p(\mathbf{x_{k}} | \mathbf{z_{k}}) - N(\mathbf{\hat{x}_{k}},\mathbf{P_{k}})
\]</span> 即为正态分布。</p>
<p>（2） <span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的推导。关于<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的形式，利用最优估计的原理，可以用极大似然估计可以推导，在论文中还看到过一种是将预测和测量的正态分布相乘求联合正态分布，联合正态分布即为后验状态估计。这里应该可以用反馈的原理来解释（如下面这张图），以测量值作为反馈，来进一步修正状态变量<span class="math inline">\(x\)</span>的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>，得到后验估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>。</p>
<img src="/skill/Understanding_of_Kalman_Filter/%E5%8F%8D%E9%A6%88%E6%A1%86%E5%9B%BE.png" class="" title="image-20210525222308034">
<p>（3） <span class="math inline">\(\mathbf{K_{k}}\)</span>的推导。既然<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>是<span class="math inline">\(\mathbf{x_{k}}\)</span>的最优估计，那么<span class="math inline">\(\mathbf{x_{k}}\)</span>的误差协方差矩阵的迹<span class="math inline">\(tr[\mathbf{P_{k}}]\)</span>(<span class="math inline">\(\mathbf{P_{k}}\)</span>的计算见下面)最小，即<span class="math inline">\(\mathbf{x_{k}}\)</span>的均方误差最小。此时，将后验估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的表达式和误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>的表达式联立，即可求得<span class="math inline">\(tr[\mathbf{P_{k}}]\)</span>，对其求导，导函数为零时求得<span class="math inline">\(\mathbf{K_{k}}\)</span>： <span class="math display">\[
\mathbf{K_{k}} = \mathbf{P_{k}^{-}}\mathbf{H^{T}}(\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R})^{-1}= 
\frac{\mathbf{P_{k}^{-}}\mathbf{H^{T}}}{\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R}}
\]</span></p>
<h2 id="离散kalman滤波算法"> 离散Kalman滤波算法</h2>
<p>卡尔曼滤波器用反馈控制的方法估计过程状态：滤波器估计某一时刻的过程状态，然后以测量变量（含噪声）的方式获得反馈。</p>
<p>因此卡尔曼滤波器可分为两个部分：时间更新方程和测量更新方程。时间更新方程负责及时向前推算当前状态变量和误差协方差估计的值，以便为下一个时间状态构造先验估计。测量更新方程负责反馈，它将先验估计和新的测量变量结合以构造改进的后验估计。时间更新方程也可视为预估方程，测量更新方程可视为校正方程。最后的估计算法成为一种具有数值解的预估－校正算法。</p>
<img src="/skill/Understanding_of_Kalman_Filter/%E9%A2%84%E6%B5%8B%E6%A0%A1%E6%AD%A3.png" class="" title="image-20210525224607696">
<p><strong>离散卡尔曼滤波时间更新方程</strong> <span class="math display">\[
\left\{\begin{matrix}
\mathbf{\hat{x}_{k}^{-}}=\mathbf{A\hat{x}_{k-1}}+\mathbf{Bu_{k-1}}
\\ 
\mathbf{P_{k}^{-}}=\mathbf{A} \boldsymbol{P_{k-1}} \mathbf{A^{T}} + \mathbf{Q}
\end{matrix}\right.
\]</span> 时间更新方程主要获取由预测方程预测的k时刻的状态<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>，为<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>的先验状态估计；此时，其误差的协方差矩阵为<span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>。</p>
<blockquote>
<p>  上式中，存在未知参数<span class="math inline">\(\mathbf{A}\)</span>, <span class="math inline">\(\mathbf{B}\)</span>, <span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>, <span class="math inline">\(\mathbf{P_{k-1}}\)</span>, <span class="math inline">\(\mathbf{Q}\)</span>  (1) 关于<span class="math inline">\(\mathbf{A}\)</span>。这是和状态向量相关的矩阵，具体见举例  (2) 关于<span class="math inline">\(\mathbf{B}\)</span>。这是驱动矩阵，和外部输入驱动有关，具体见举例  (3) 关于 <span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>。这是k时刻的先验状态估计的误差协方差矩阵，与预测方程的噪声有关，是根据（k-1）时刻的误差协方差矩阵<span class="math inline">\(\mathbf{P_{k-1}}\)</span>递推而来（<span class="math inline">\(\mathbf{P_{k-1}}\)</span>一般是给定的初值），利用<span class="math inline">\(\mathbf{P_{k}^{-}}\)</span>的表达式 <span class="math inline">\(\mathbf{P_{k}^{-}} = E[\mathbf{e_{k}^{-}}  \mathbf{(e_{k}^{-})^{T}}]\)</span>即可求得。  (4) 关于<span class="math inline">\(\mathbf{P_{k-1}}\)</span>。（k-1）时刻的误差协方差矩阵（<span class="math inline">\(\mathbf{P_{k-1}}\)</span>一般是给定的初值）  (5) 关于<span class="math inline">\(\mathbf{Q}\)</span>。过程噪声（预测误差）<span class="math inline">\(\mathbf{w_{k-1}}\)</span>的协方差矩阵，在预测的过程中产生。</p>
</blockquote>
<p><strong>离散卡尔曼滤波状态更新方程</strong> <span class="math display">\[
\left\{\begin{matrix}
\mathbf{K_{k}} = \mathbf{P_{k}^{-}}\mathbf{H^{T}}(\mathbf{H}\mathbf{P_{k}^{-}}\mathbf{H^{T}}+\mathbf{R})^{-1}
\\
\mathbf{\hat{x}_{k}} = \mathbf{\hat{x}_{k}^{-}} + \mathbf{K_{k}} (\mathbf{z_{k}} - \mathbf{H} \mathbf{\hat{x}_{k}^{-}})
\\ 
\mathbf{P_{k}}=(\mathbf{I} - \mathbf{K_{k}}\mathbf{H} )\mathbf{P_{k}^{-}}
\end{matrix}\right.
\]</span> 状态更新方程在预测的先验估计<span class="math inline">\(\mathbf{\hat{x}_{k}^{-}}\)</span>上，同测量值<span class="math inline">\(\mathbf{z_{k}}\)</span>进行融合，更新校正先验状态估计，得到k时刻的后验状态估计<span class="math inline">\(\mathbf{\hat{x}_{k}}\)</span>；此时，递推出后验状态估计的误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>，由此可以得到MMSE的条件，求得<span class="math inline">\(\mathbf{K_{k}}\)</span></p>
<blockquote>
<p>  上式中，存在未知参数<span class="math inline">\(\mathbf{K_{k}}\)</span>, <span class="math inline">\(\mathbf{H}\)</span>, <span class="math inline">\(\mathbf{R}\)</span>, <span class="math inline">\(\mathbf{z_{k}}\)</span>, <span class="math inline">\(\mathbf{P_{k}}\)</span>  (1) 关于<span class="math inline">\(\mathbf{K_{k}}\)</span>。残差（真实测量值与基于先验状态估计的测量值（估计量））的增益，可以看做测量反馈的增益  (2) 关于<span class="math inline">\(\mathbf{H}\)</span>。这是观测矩阵，和状态向量有关，具体见举例  (3) 关于<span class="math inline">\(\mathbf{R}\)</span>。测量噪声（测量误差）<span class="math inline">\(\mathbf{v_{k-1}}\)</span>的协方差矩阵，在测量的过程中产生。   (4) 关于<span class="math inline">\(\mathbf{z_{k}}\)</span>。k时刻的真是测量值。  (5) 关于<span class="math inline">\(\mathbf{P_{k}}\)</span>。k时刻的后验估计的误差协方差矩阵。</p>
</blockquote>
<p>因此，通过时间更新和测量更新的不断递推，便可得到比较准确的状态向量估计值。其中，若初始过程噪声<span class="math inline">\(w_{k}\)</span>和测量噪声<span class="math inline">\(v_{k}\)</span>为一确定值，不断递推后状态向量误差协方差矩阵<span class="math inline">\(\mathbf{P_{k}}\)</span>和卡尔曼增益<span class="math inline">\(\mathbf{K_{k}}\)</span>会收敛并保持常量。下图显示了滤波器整个操作流程。</p>
<img src="/skill/Understanding_of_Kalman_Filter/%E6%BB%A4%E6%B3%A2%E5%99%A8%E6%B5%81%E7%A8%8B.png" class="" title="image-20210525224729900">
<hr />
<h1 id="程序">程序</h1>
<h2 id="matlab程序"> Matlab程序</h2>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% kalman filter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% x(k+1) = Fk * x(k) + Wk; 预测模型</span></span><br><span class="line"><span class="comment">% y(k)   = Hk * x(k) + Vk; 观测模型</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">365</span>;</span><br><span class="line"></span><br><span class="line">Fk = [<span class="number">1</span>];               <span class="comment">% 状态转移矩阵               </span></span><br><span class="line">X  = <span class="built_in">zeros</span>(N,<span class="number">1</span>);        <span class="comment">% 初始化状态变量</span></span><br><span class="line">W  = <span class="number">12</span>*<span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 构造过程噪声</span></span><br><span class="line">X(<span class="number">1</span>) = <span class="number">100</span>;             <span class="comment">% 初始状态</span></span><br><span class="line">                    </span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 状态方程</span></span><br><span class="line">    X(k) = Fk * X(k<span class="number">-1</span>) + W(k<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Hk = [<span class="number">2</span>];               <span class="comment">% 观测矩阵                </span></span><br><span class="line">Y  = <span class="built_in">zeros</span>(N,<span class="number">1</span>);        <span class="comment">% 初始化观测变量</span></span><br><span class="line">V  = <span class="number">20</span>*<span class="built_in">randn</span>(N,<span class="number">1</span>);     <span class="comment">% 构造观测噪声</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:N</span><br><span class="line">    <span class="comment">% 观测方程</span></span><br><span class="line">    Y(k) = Hk * X(k) + V(k);   </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Q  = cov(W);            <span class="comment">% 过程噪声协方差；    </span></span><br><span class="line">R  = cov(V);            <span class="comment">% 观测噪声协方差；          </span></span><br><span class="line"></span><br><span class="line">Xupdate = <span class="built_in">zeros</span>(N,<span class="number">1</span>);   </span><br><span class="line">Xupdate(<span class="number">1</span>) = Y(<span class="number">1</span>);      <span class="comment">% 初始化第一个，也就是观测到的第一个 </span></span><br><span class="line">Pupdate(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 五大核心方程</span></span><br><span class="line">    Xpredict(k) = Fk * Xupdate(k<span class="number">-1</span>);</span><br><span class="line">    Ppredict(k) = Fk * Pupdate(k<span class="number">-1</span>) * Fk&#x27; + Q;</span><br><span class="line">    K = Ppredict(k) * Hk * (Hk * Ppredict(k) * Hk&#x27; + R).^<span class="number">-1</span>;</span><br><span class="line">    Xupdate(k) = (<span class="number">1</span> - K * Hk) * Xpredict(k) + K * Y(k);</span><br><span class="line">    Pupdate(k) = (<span class="number">1</span> - K * Hk) * Ppredict(k);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,X,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,Y,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,Xupdate,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:N,<span class="built_in">abs</span>(Xupdate-X),<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">2</span>);<span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;真值&#x27;</span>,<span class="string">&#x27;观测值&#x27;</span>,<span class="string">&#x27;滤波值&#x27;</span>,<span class="string">&#x27;误差&#x27;</span>)</span><br></pre></td></tr></table></figure>
<hr />
<h1 id="参考">参考</h1>
<ul>
<li>https://www.zhihu.com/question/23971601  </li>
<li>http://blog.csdn.net/xiahouzuoxin/article/details/39582483  </li>
<li>https://zhuanlan.zhihu.com/p/21889676  </li>
<li>https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2  </li>
<li>https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95</li>
<li>http://www.jianshu.com/p/2768642e3abf</li>
<li>http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/</li>
<li>Ramsey Faragher. Understanding the Basis of the Kalman Filter. 2012</li>
<li>Greg Welch, Gary Bishop. An Introduction to the Kalman Filter. 2001</li>
<li>Don Johnson. Minimum Mean Squared Error Estimators. 2004</li>
<li>R.E.Kalman. A new approach to linear filtering and prediction problems. 1960</li>
</ul>
]]></content>
      <categories>
        <category>问术</category>
      </categories>
      <tags>
        <tag>Kalman filter</tag>
      </tags>
  </entry>
</search>
